{"pages":[],"posts":[{"title":"[DASCTF2024夏季挑战赛]StrangePrograme","text":"眼前所见，亦非真实 你看到的我并不是真正的我，你看到的memcmp不是真正的memcmp 为什么memcmp要保留它当memcmp函数的历史 因为它是钩子 .DASCTF段一大段爆红，首先想到smc 跟随IsDebuggerPresent()的脚步来到这个函数 找到smc的地方 下面是被加密的.DASCTF段 断点一打，开始调试 .DASCTF段解密后恢复里面的几个关键函数 这里，memcmp被hook了，它已经不是原来的memcmp了 这里是加密 TEA 此时如果回主函数找到memcmp，一路跟进，会来到这个地方，这是动态链接库里的memcmp 总得来说，被hook的函数会改变它原本的功能，所以main函数里的memcmp并不是比较，而是加密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;bits/stdc++.h&gt;using namespace std;void De_tea(unsigned int *a1, unsigned int *a2){ unsigned int i; // [esp+DCh] [ebp-2Ch] int v4; // [esp+E8h] [ebp-20h] unsigned int v5; // [esp+F4h] [ebp-14h] unsigned int v6; // [esp+100h] [ebp-8h] v6 = *a1; v5 = a1[1]; // for (i = 0; i &lt; 16; ++i) // { // v6 += (a2[1] + (v5 &gt;&gt; 5)) ^ (v4 + v5) ^ (*a2 + 16 * v5); // v5 += (a2[3] + (v6 &gt;&gt; 5)) ^ (v4 + v6) ^ (a2[2] + 16 * v6); // v4 -= 1640531527; // } v4 = 0 - 16 * 0x61C88647; for (i = 0; i &lt; 16; ++i) { v4 += 0x61C88647; v5 -= (a2[3] + (v6 &gt;&gt; 5)) ^ (v4 + v6) ^ (a2[2] + 16 * v6); v6 -= (a2[1] + (v5 &gt;&gt; 5)) ^ (v4 + v5) ^ (*a2 + 16 * v5); } *a1 = v6; a1[1] = v5;}int main(){ __int64 v1; // rax __int64 v3; // [esp-8h] [ebp-24Ch] int j; // [esp+D0h] [ebp-174h] size_t i; // [esp+F4h] [ebp-150h] char *v6; // [esp+100h] [ebp-144h] unsigned int v7; // [esp+124h] [ebp-120h] BYREF int v8; // [esp+128h] [ebp-11Ch] int v9; // [esp+12Ch] [ebp-118h] int v10; // [esp+130h] [ebp-114h] unsigned char v11[41]; // [esp+13Ch] [ebp-108h] BYREF int savedregs; // [esp+244h] [ebp+0h] BYREF v11[0] = 0xF9; v11[1] = 0x4D; v11[2] = 0x2B; v11[3] = 0xBC; v11[4] = 0x13; v11[5] = 0xDD; v11[6] = 0x13; v11[7] = 0x62; v11[8] = 0xC9; v11[9] = 0xFC; v11[10] = 0xFF; v11[11] = 0x89; v11[12] = 0x7D; v11[13] = 0x4F; v11[14] = 0xC9; v11[15] = 0xF; v11[16] = 0x63; v11[17] = 0x1D; v11[18] = 0x6D; v11[19] = 0x52; v11[20] = 0x50; v11[21] = 0xFD; v11[22] = 0x41; v11[23] = 0xE3; v11[24] = 0x33; v11[25] = 0x76; v11[26] = 0x28; v11[27] = 0x97; v11[28] = 0x38; v11[29] = 0x36; v11[30] = 0xF9; v11[31] = 0x6B; v11[32] = 0x90; v11[33] = 0x39; v11[34] = 0x14; v11[35] = 0x83; v11[36] = 0x2C; v11[37] = 0xE2; v11[38] = 0x2C; v11[39] = 0x1F; v11[40] = 0x0; // unsigned int enc[10] = { // 0xBC2B4DF9, 0x6213DD13, 0x89FFFCC9, 0x0FC94F7D, 0x526D1D63, 0xE341FD50, 0x97287633, 0x6BF93638, // 0x83143990, 0x1F2CE22C}; // unsigned int key[4] = { // 0x12345678, 0x09101112, 0x13141516, 0x15161718}; // v8 = *(v11 + 1); // *v6 = v8; unsigned char key[16] = { 0x78, 0x56, 0x34, 0x12, 0x12, 0x11, 0x10, 0x09, 0x16, 0x15, 0x14, 0x13, 0x18, 0x17, 0x16, 0x15}; unsigned int *p = (unsigned int *)v11; for (int i = 8; i &gt;= 2;i -= 2){ // *&amp;v11[4 * i + 4] ^= *v11; // *&amp;v11[4 * 1] ^= *v6; // *(unsigned int *)&amp;v11[4 * i + 4] ^= p[1]; // *(unsigned int *)&amp;v11[4 * i] ^= p[0]; *(unsigned int *)&amp;v11[4 * i + 4] ^= v11[1]; *(unsigned int *)&amp;v11[4 * i] ^= v11[0]; // enc[i] ^= enc[1]; // enc[i - 1] ^= enc[0]; De_tea(p, (unsigned int *)key); // De_tea((unsigned int *)v11, (unsigned int *)key); } De_tea(p, (unsigned int *)key); for(int i = 0; i &lt; 40;++ i) printf(&quot;%c&quot;, v11[i]); return 0;} 接下来表演的节目是神奇的指针 当我将exp中间部分写成这样时 12*(unsigned int *)&amp;v11[4 * i + 4] ^= *(unsigned int *)v11[1];*(unsigned int *)&amp;v11[4 * i] ^= *(unsigned int *)v11[0]; 它的输出是这样的 当我写成这样时 123unsigned int *p = (unsigned int *)v11;*(unsigned int *)&amp;v11[4 * i + 4] ^= p[1];*(unsigned int *)&amp;v11[4 * i] ^= p[0]; 它的输出是这样的 当我写成这样时 12*(unsigned int *)&amp;v11[4 * i + 4] ^= v11[1];*(unsigned int *)&amp;v11[4 * i] ^= v11[0]; 它的输出是这样的 指针，很神奇吧","link":"/2024/07/25/DASCTF2024%E5%A4%8F%E5%AD%A3%E6%8C%91%E6%88%98%E8%B5%9B-StrangePrograme/"},{"title":"临江仙","text":"青山依旧在，几度夕阳红 临江仙【明】杨慎滚滚长江东逝水，浪花淘尽英雄。是非成败转头空。青山依旧在，几度夕阳红。白发渔樵江渚上，惯看秋月春风。一壶浊酒喜相逢。古今多少事，都付笑谈中。","link":"/2024/07/25/%E4%B8%B4%E6%B1%9F%E4%BB%99/"},{"title":"报任安书","text":"然此可为智者道，难为俗人言也 报任安书（节选）【两汉】司马迁古者富贵而名摩灭，不可胜记，唯倜傥非常之人称焉。盖文王拘而演《周易》；仲尼厄而作《春秋》；屈原放逐，乃赋《离骚》；左丘失明，厥有《国语》；孙子膑脚，《兵法》修列；不韦迁蜀，世传《吕览》；韩非囚秦，《说难》《孤愤》；《诗》三百篇，大底圣贤发愤之所为作也。此人皆意有所郁结，不得通其道，故述往事、思来者。乃如左丘无目，孙子断足，终不可用，退而论书策，以舒其愤，思垂空文以自见。 仆窃不逊，近自托于无能之辞，网罗天下放失旧闻，略考其行事，综其终始，稽其成败兴坏之纪，上计轩辕，下至于兹，为十表，本纪十二，书八章，世家三十，列传七十，凡百三十篇。亦欲以究天人之际，通古今之变，成一家之言。草创未就，会遭此祸，惜其不成，是以就极刑而无愠色。仆诚以著此书，藏之名山，传之其人，通邑大都，则仆偿前辱之责，虽万被戮，岂有悔哉！然此可为智者道，难为俗人言也！","link":"/2024/07/26/%E6%8A%A5%E4%BB%BB%E5%AE%89%E4%B9%A6/"},{"title":"360加固保免费版分析","text":"分析360加固保免费版，学习逆向技术（此篇未完结） 使用360加固保免费版加固，注意加固时要把签名校验给去除，因为加固之后的app是没有签名的，自己签名之后如果有签名校验，程序可能会闪退 ‍ Java层分析这是我自己写的一个app，可以看到没有加固时可以直接看到MainActivity 加固之后MainActivity字样没了，出现了StubAPP类和tianyu.util字样，可以知道这就是该加固的特征 StubApp类里面使用a方法传递了一串字符串，跟进a方法，注意a有多个重载方法，需要查看具有一个字符串参数的重载方法 发现就是对字符串进行一个解混淆，方式为异或16，这里可以用Cyberchef先解一下看看 使用Frida hook看看这个方法做了些什么，直接在jadx里选择复制为frida片段 12345678910111213141516171819function hook() { let a = Java.use(&quot;com.tianyu.util.a&quot;); a[&quot;a&quot;].overload('java.lang.String').implementation = function (str) { console.log(`a.a is called: str=${str}`); let result = this[&quot;a&quot;](str); console.log(`a.a result=${result}`); return result; };}function main() { Java.perform(function () { hook(); })} 可以看到就是加载了一些Android系统内部类或方法名 继续观察StubApp类，看见下面会根据设备的架构来加载不同的so文件 再与正常未加固的apk对比一下，发现加固之后的apk多了一个assets文件夹，里面存着一些so文件 不难分析出，该加固是在Native层来释放dex文件 ‍ Native层分析分析so文件，发现导入导出表被抹除得一干二净 如果没有导入导出表的话，elf文件应该是使用了自定义的动态链接器来进行链接的，所以，只要再elf文件被装载进内存之后将它dump下来，应该就能恢复符号表了 在Linux系统中，dlopen函数用于动态链接库加载函数，它存在于libdl.so库中 123456789101112131415161718192021// 1. 加载库void* libHandle = dlopen(&quot;/data/data/pkg/libnative.so&quot;, RTLD_NOW);if (!libHandle) { printf(&quot;Error: %s\\n&quot;, dlerror()); return;}// 2. 获取函数指针typedef int (*NativeFunc)(int);NativeFunc func = (NativeFunc)dlsym(libHandle, &quot;native_add&quot;);if (!func) { printf(&quot;Error: %s\\n&quot;, dlerror()); dlclose(libHandle); return;}// 3. 调用函数int result = func(42);// 4. 卸载库dlclose(libHandle); 在安卓7.0之后，则需要hook的是android_dlopen_ext函数 frida hook一下看看它加载了哪些函数 android_dlopen_ext() 的格式为android_dlopen_ext(&quot;/data/data/pkg/libsecret.so&quot;, RTLD_NOW, NULL);，所以我们需要获取第一个参数的值来得到它链接了哪些so文件 1234567891011121314151617181920212223function hook() { Interceptor.attach(Module.findExportByName(&quot;libdl.so&quot;, &quot;android_dlopen_ext&quot;), { onEnter: function (args) { // console.log('Entering ' + functionName); // Modify or log arguments if needed console.log(&quot;load -&gt; &quot;, args[0].readCString()); }, onLeave: function (retval) { // console.log('Leaving ' + functionName); // Modify or log return value if needed } });}function main() { Java.perform(function () { hook(); })}setImmediate(main); 正如所料，它链接了这个so文件 接下来在它将该so文件装载到内存之后dump下来，就可以得到带有导入导出表的so文件了 （dump脚本来自SWDD） 1234567891011121314151617function dump_so() { var soName = &quot;libjiagu_64.so&quot;; var libSo = Process.getModuleByName(soName); var save_path = &quot;/data/data/com.example.nativetest/&quot; + libSo.name + &quot;_Dump&quot;; console.log(&quot;[Base]-&gt;&quot;, libSo.base); console.log(&quot;[Size]-&gt;&quot;, ptr(libSo.size)); var handle = new File(save_path, &quot;wb&quot;); Memory.protect(ptr(libSo.base), libSo.size, 'rwx'); var Buffer = libSo.base.readByteArray(libSo.size); handle.write(Buffer); handle.flush(); handle.close(); console.log(&quot;[DumpPath-&gt;]&quot;, save_path);}setImmediate(dump_so); 注意，要在app运行之后再把脚本附加上去，否则如果还没来得及链接就dump的话，frida会直接报错 所以这里使用命令 1frida -U 'NativeTest' -l dump_so.js 成功dump，并且得到了文件的基地址和大小 成功恢复 ‍ 壳文件分析这里有一个知识点 加固壳的典型行为模式加固壳的核心任务是 保护原始代码，其常见流程包括： 解密资源： 原始 APK/Dex/So 文件被加密，隐藏在 assets、lib/ 或自定义目录中。 运行时，壳代码需要先 读取这些加密文件（通过 open + read）。 动态加载： 解密后的文件（如 Dex、So）会通过 dlopen、mmap 或 DexClassLoader 加载到内存。 内存执行： 解密后的代码在内存中执行，避免留下完整的磁盘文件。 关键点：➜ 加固壳必须读取加密文件 → 必然调用 open 函数 → Hook ​open​ 可以捕获文件访问路径。 思路就是 hook open函数来看看它有没有读取什么东西 1234567891011121314151617181920212223242526function hook() { var openPtr = Module.findExportByName(null, &quot;open&quot;); // var openAdrr = new NativePointer(openPtr); const open = new NativeFunction(openPtr, 'int', ['pointer', 'int']); Interceptor.replace(openPtr, new NativeCallback(function (fileNamePtr, flag) { var fileName = fileNamePtr.readCString(); console.log(&quot;[open : ]&quot;, fileName); return open(fileNamePtr, flag); } , 'int', ['pointer', 'int']))}function main() { Java.perform(function () { hook(); })}// setTimeout(main, 1000);setImmediate(main); 注意这里一定要new一个NativeCallback 在 Frida 中，NativeCallback 的作用是 创建一个符合原生代码调用约定的 JavaScript 回调函数，用于替换或拦截原生函数（如 open） 原生代码（如 C 的 open 函数）有严格的 参数传递规则（如寄存器/栈传参、类型转换），而 JavaScript 是弱类型语言，无法直接匹配 不然的话会出现如下报错 fileNamePtr 可能未被正确识别为 pointer 类型 可以看到打开了如下文件 发现个很可疑的点，它频繁访问了 /proc/self/maps ​/proc/self/maps​ 的作用 功能：该文件实时显示当前进程的内存映射布局，包括： 加载的模块（.so/.dex）基地址和大小 内存权限（可读/可写/可执行） 文件来源路径 典型访问场景： 加固壳：检测内存是否被篡改（反调试）。 动态加载库：定位空闲内存区域加载新代码。 内存扫描：查找敏感数据或函数地址。 这里反复读取maps猜测是为了混淆视听，当加载dex时，maps上的内存映射会发生变化，留下记录，比如 /data/app/xxx/base.dex，这时候壳文件就通过反复读取maps来隐藏打开dex的操作，掩盖真正的 Dex 加载时机 此时，如果我们自定义一个fakeMaps，将壳文件对maps的操作重定向到我们的fakeMaps上，就可以很方便地观察壳文件加载dex的操作了，同时也能避免壳的反检测机制（如果有的话） 123456789101112131415161718192021222324252627282930313233343536373839404142434445function hook() { var openPtr = Module.findExportByName(null, &quot;open&quot;); // var openAdrr = new NativePointer(openPtr); const open = new NativeFunction(openPtr, 'int', ['pointer', 'int']); var fakeMaps = &quot;/data/data/com.example.nativetest/maps&quot; Interceptor.replace(openPtr, new NativeCallback(function (fileNamePtr, flag) { var fileName = fileNamePtr.readCString(); console.log(&quot;[open : ]&quot;, fileName); var FD = open(fileNamePtr, flag); //调用原始open函数，记录原始open函数的文件描述符 if (fileName.indexOf(&quot;maps&quot;) &gt;= 0) { //如果文件名包含maps，将其重定向到fakeMaps上 console.log(&quot;sucess find maps&quot;); var fakeMapsAddr = Memory.allocUtf8String(fakeMaps); return open(fakeMapsAddr, flag); // 打开伪造的maps文件，并返回其文件描述符（FD），而非真实的maps } if (fileName.indexOf(&quot;dex&quot; != -1)) { console.warn(&quot;open dex :&quot;, fileName); } return FD; //返回原始FD使app正常运行 // return open(fileNamePtr, flag); }, 'int', ['pointer', 'int']))}function main() { Java.perform(function () { hook(); })}// setTimeout(main, 1000);setImmediate(main); 可以发现确实是通过open去打开了dex文件，而且通过反复读取了maps来隐藏操作，验证了我们之前的猜想 使用来查看dex的内存地址 1console.warn('dex called from:\\n' + Thread.backtrace(this.context, Backtracer.FUZZY).map(DebugSymbol.fromAddress).join('\\n') + '\\n'); 12345678910111213141516171819202122232425262728293031323334353637383940414243function hook() { var openPtr = Module.findExportByName(null, &quot;open&quot;); // var openAdrr = new NativePointer(openPtr); const open = new NativeFunction(openPtr, 'int', ['pointer', 'int']); var fakeMaps = &quot;/data/data/com.example.nativetest/maps&quot;; Interceptor.replace(openPtr, new NativeCallback(function (fileNamePtr, flag) { var fileName = fileNamePtr.readCString(); console.log(&quot;[open : ]&quot;, fileName); var FD = open(fileNamePtr, flag); //调用原始open函数，记录原始open函数的文件描述符 if (fileName.indexOf(&quot;maps&quot;) &gt;= 0) { //如果文件名包含maps，将其重定向到fakeMaps上 console.log(&quot;sucess find maps&quot;); var fakeMapsAddr = Memory.allocUtf8String(fakeMaps); return open(fakeMapsAddr, flag); // 打开伪造的maps文件，并返回其文件描述符（FD），而非真实的maps } if (fileName.indexOf(&quot;dex&quot;) != -1) { console.warn(&quot;open dex :&quot;, fileName); console.warn('dex called from:\\n' + Thread.backtrace(this.context, Backtracer.FUZZY).map(DebugSymbol.fromAddress).join('\\n') + '\\n'); } return FD; //返回原始FD使app正常运行 // return open(fileNamePtr, flag); }, 'int', ['pointer', 'int']))}function main() { Java.perform(function () { hook(); })}// setTimeout(main, 1000);+setImmediate(main); 可以发现打开dex的地址基本一模一样，在IDA中查看这个地址 嘶，啥也没有，这不对吧 查阅多方资料，发现我漏了一步，在先前dump so文件的时候，so文件可能会有损坏，所以先需要修复一下so文件 使用soFixer soFixer 0x0x7fff56d99000是之前dump so文件的时候输出的基地址 1.\\SoFixer-Windows-64.exe -s .\\libjiagu_64.so_Dump -o .\\libjiagu_64.so_Fix -m 0x7fff56d99000 -d 使用sofix之后IDA将其识别成了ARM架构，但是我原本的文件是x86_64架构，这里要重新选择一下 这下就没问题了 但是这段数据全是未定义的，这个时候就手足无措了 一通乱翻，发现了这样一个函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596char __fastcall __arm_a_2(char *a1, unsigned __int64 a2, char *a3, int *a4, unsigned int a5){ unsigned __int64 v5; // rax __int64 *v6; // rsi __int64 v7; // rbx __int64 *v8; // rdi __int64 v9; // rax _QWORD *v10; // rbx char v12[8]; // [rsp+90h] [rbp-168h] BYREF unsigned __int64 v13; // [rsp+98h] [rbp-160h] __int64 v14; // [rsp+A0h] [rbp-158h] __int64 v15[7]; // [rsp+B0h] [rbp-148h] BYREF _QWORD v16[2]; // [rsp+E8h] [rbp-110h] BYREF __int128 v17; // [rsp+F8h] [rbp-100h] __int128 v18[8]; // [rsp+108h] [rbp-F0h] BYREF __int128 v19; // [rsp+188h] [rbp-70h] __int128 v20; // [rsp+198h] [rbp-60h] __int128 v21[2]; // [rsp+1A8h] [rbp-50h] BYREF int *v22; // [rsp+1D0h] [rbp-28h] unsigned __int64 v23; // [rsp+1D8h] [rbp-20h] unsigned __int64 v24; // [rsp+1E8h] [rbp-10h] v24 = __readfsqword(0x28u); v23 = a5; v22 = a4; sub_2DA0(); v5 = __readfsqword(0x28u); if ( v5 != v24 ) { sub_2D40(qword_1C928, 0x190LL); v23 = a1; v22 = __readfsqword(0x28u); memset(v21, 0, sizeof(v21)); v20 = 0LL; v19 = 0LL; memset(v18, 0, sizeof(v18)); v17 = 0LL; sub_2D20(v18 + 4, &quot;*.so&quot;, 0x80LL, 0xBCLL, 5LL); v16[0] = &amp;qword_234D0; v16[1] = 0xAC3FDLL; LODWORD(v18[0]) = 1; *&amp;v20 = off_233B8; *(&amp;v19 + 1) = &amp;qword_CFD40; DWORD2(v21[1]) = 1; *(&amp;v20 + 1) = 0x400000002LL; LODWORD(v21[0]) = 5; *(v21 + 8) = 0LL; sub_7330(v15); v15[0] = qword_22CA8 + 16; v6 = &amp;qword_CF8D0; if ( sub_7770(v15, &amp;qword_CF8D0, 1062LL) ) { v6 = v15; v7 = sub_5C10(v16, v15); if ( *(&amp;v21[0] + 1) ) (sub_2EE0)(); } else { v7 = 0LL; } v8 = v15; sub_7580(v15); if ( __readfsqword(0x28u) == v22 ) { LOBYTE(v5) = v7; } else { sub_2D40(v15, v6); v14 = v7; v13 = __readfsqword(0x28u); if ( v15 ) { strcpy(v12, &quot;makekey&quot;); v6 = v12; v9 = sub_5D40(v15, v12); if ( v9 ) { v10 = v9; v8 = (v9 &amp; 0xFFFFFFFFFFFFF000LL); v6 = (&quot;pthread_create&quot; + 3); sub_2E50(v9 &amp; 0xFFFFFFFFFFFFF000LL, 4096LL, 3LL); *v10 = qword_22CC0; } } v5 = __readfsqword(0x28u); if ( v5 != v13 ) { sub_2D40(v8, v6); LOBYTE(v5) = 1; } } } return v5;} 查看sub_50E0 发现了一些用于加载动态链接相关的字符串，结合之前创建线程，这个时候就猜测，应该已经在加载另外的so了 ‍ 安卓系统中，完成linker之后，dlopen去加载这个so，我们之前hook的是android_dlopen_ext，这里再去hook一下dlopen看看它加载了哪些so文件 1234567891011121314151617181920212223242526272829303132333435363738394041function hook() { Interceptor.attach(Module.findExportByName(&quot;libdl.so&quot;, &quot;android_dlopen_ext&quot;), { onEnter: function (args) { // console.log('Entering ' + functionName); // Modify or log arguments if needed console.log(&quot;load -&gt; &quot;, args[0].readCString()); }, onLeave: function (retval) { // console.log('Leaving ' + functionName); // Modify or log return value if needed } });}function hook2() { Interceptor.attach(Module.findExportByName(&quot;libdl.so&quot;, &quot;dlopen&quot;), { onEnter: function (args) { // console.log('Entering ' + functionName); // Modify or log arguments if needed console.warn(&quot;dlopen load -&gt; &quot;, args[0].readCString()); }, onLeave: function (retval) { // console.log('Leaving ' + functionName); // Modify or log return value if needed } });}function main() { Java.perform(function () { hook(); hook2(); })}// setTimeout(main, 1000);setImmediate(main); 看到这里，基本上可以说明就是自定义linker加固so文件了 ‍ 查阅资料发现，自定义linker加固so的流程是，自定义文件格式加密so，然后壳代码实现将加密的so文件加载，链接重定位并修正soinfo（三部曲） 简单来说就是将elf文件的.text等数据段进行加密，然后在link的时候补充soinfo soinfo 是 Android linker 内部维护的数据结构，用于 管理已加载的共享库（.so） 。每个被 dlopen 或程序依赖的 .so 都会有一个对应的 soinfo 结构，存储： 库的基地址（加载地址） 符号表、重定位表、依赖关系 动态段（​ ​.dynamic​​ ）解析后的信息 命名空间（用于库隔离） ​soinfo​ 的生命周期 加载阶段：dlopen → linker 解析 ELF → 创建 soinfo 并填充信息。 链接阶段：linker 根据 .dynamic 段解析依赖、符号、重定位。 运行时：dlsym 通过 soinfo 查找符号地址。 卸载阶段：dlclose 释放 soinfo。 由于之前的so在执行的时候link了另外的so，所以将其放入010editor里查找elf头 找到了elf头，并且可以看到program header已经被加密了 写一个脚本，将0xd0000之后的内容提取出来 提取出来的so文件ida是打不开的，因为program header已经被加密了 此时就需要找到这个so是在哪里被解密的 用oacia大佬的项目来分析一下程序执行流 https://github.com/oacia/stalker_trace_so 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960[Android Emulator 5554::com.example.nativetest ]-&gt; start Stalker!Stalker end!call1:JNI_OnLoadcall2:sub_C840call3:ffi_callcall4:sub_C450call5:sub_7330call6:sub_7770call7:sub_7370call8:_ZN9__arm_c_19__arm_c_0Evcall9:sub_77B0call10:sub_71F0call11:sub_C560call12:sub_7240call13:sub_42C0call14:sub_6310call15:sub_6A30call16:sub_6760call17:sub_4B40call18:sub_4F70call19:sub_50E0call20:sub_3B20call21:sub_7000call22:sub_6350call23:sub_7580call24:sub_10E1D0call25:sub_1BC3C0call26:sub_10B270call27:sub_1465C0call28:sub_14AC90call29:sub_10A5C0call30:sub_1BDD20call31:sub_14B3E0call32:sub_14D100call33:sub_1BDD50call34:sub_1A9BD0call35:sub_1459B0call36:sub_1BD700call37:sub_1BD790call38:sub_10ED90call39:sub_1120F0call40:sub_10CC10call41:sub_106F90call42:sub_1BB530call43:sub_1BB620call44:sub_1BC4E0call45:sub_1BB980call46:sub_1BBC00call47:sub_1BBE10call48:sub_1BC1D0call49:sub_1BC4B0call55:sub_1BDF10call56:sub_116720call57:sub_1BDD00call58:sub_1AD9E0call59:sub_1ADB60call60:sub_1C49A0call61:sub_1CAD30call62:sub_1C8EC0call63:sub_16FA70 再看一下fix之后的文件的控制流 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364[Android Emulator 5554::com.example.nativetest ]-&gt; start Stalker!call1:JNI_OnLoadcall2:sub_C840call3:ffi_callcall4:sub_C450call5:sub_7330call6:sub_7770call7:sub_7370call8:_ZN9__arm_c_19__arm_c_0Evcall9:sub_77B0call10:sub_71F0call11:sub_C560call12:sub_7240call13:sub_42C0call14:sub_6310call15:sub_6A30call16:sub_6760call17:sub_4B40call18:sub_4F70call19:sub_50E0call20:sub_3B20call21:sub_7000call22:sub_6350call23:sub_7580call24:sub_10E1D0call25:sub_1BC3C0call26:sub_10B270call27:sub_1465C0call28:sub_14AC90call29:sub_10A5C0call30:sub_1BDD20call31:sub_14B3E0call32:sub_14D100call33:sub_1BDD50call34:sub_1A9BD0call35:sub_1459B0call36:sub_1BD700call37:sub_1BD790call38:sub_10ED90call39:sub_1120F0call40:sub_10CC10call41:sub_106F90call42:sub_1BB530call43:sub_1BB620call44:sub_1BC4E0call45:sub_1BB980call46:sub_1BBC00call47:sub_1BBE10call48:sub_1BC1D0call49:sub_1BC4B0call50:sub_14B000call51:sub_14D310call52:_Z9__arm_a_2PcmS_Riicall53:sub_14ACC0call54:sub_10C5F0call55:sub_1BDF10call56:sub_116720call57:sub_1BDD00call58:sub_1AD9E0call59:sub_1ADB60call60:sub_1C49A0call61:sub_1CAD30call62:sub_1C8EC0call63:sub_16FA70 ‍ ‍ 知道了控制流之后，虽然是自定义linker加固so，但是最后肯定还是需要dlopen去加载so的，在IDA里交叉引用一下dlopen，看看在哪里被调用了 只有一处调用，全是switch case结构 查看Android源码linker的预链接部分，同样也是大量的switch case结构 此时就可以在IDA中导入soinfo结构体了（结构体代码来自SWDD） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296//IMPORTANT//ELF64 启用该宏#define __LP64__ 1//ELF32 启用该宏//#define __work_around_b_24465209__ 1 /*//https://android.googlesource.com/platform/bionic/+/master/linker/Android.bp架构为 32 位 定义__work_around_b_24465209__宏arch: { arm: {cflags: [&quot;-D__work_around_b_24465209__&quot;],}, x86: {cflags: [&quot;-D__work_around_b_24465209__&quot;],}, }*/ //android-platform\\bionic\\libc\\include\\link.h#if defined(__LP64__)#define ElfW(type) Elf64_ ## type#else#define ElfW(type) Elf32_ ## type#endif //android-platform\\bionic\\linker\\linker_common_types.h// Android uses RELA for LP64.#if defined(__LP64__)#define USE_RELA 1#endif //android-platform\\bionic\\libc\\kernel\\uapi\\asm-generic\\int-ll64.h//__signed__--&gt;signedtypedef signed char __s8;typedef unsigned char __u8;typedef signed short __s16;typedef unsigned short __u16;typedef signed int __s32;typedef unsigned int __u32;typedef signed long long __s64;typedef unsigned long long __u64; //A12-src\\msm-google\\include\\uapi\\linux\\elf.h/* 32-bit ELF base types. */typedef __u32 Elf32_Addr;typedef __u16 Elf32_Half;typedef __u32 Elf32_Off;typedef __s32 Elf32_Sword;typedef __u32 Elf32_Word; /* 64-bit ELF base types. */typedef __u64 Elf64_Addr;typedef __u16 Elf64_Half;typedef __s16 Elf64_SHalf;typedef __u64 Elf64_Off;typedef __s32 Elf64_Sword;typedef __u32 Elf64_Word;typedef __u64 Elf64_Xword;typedef __s64 Elf64_Sxword; typedef struct dynamic{ Elf32_Sword d_tag; union{ Elf32_Sword d_val; Elf32_Addr d_ptr; } d_un;} Elf32_Dyn; typedef struct { Elf64_Sxword d_tag; /* entry tag value */ union { Elf64_Xword d_val; Elf64_Addr d_ptr; } d_un;} Elf64_Dyn; typedef struct elf32_rel { Elf32_Addr r_offset; Elf32_Word r_info;} Elf32_Rel; typedef struct elf64_rel { Elf64_Addr r_offset; /* Location at which to apply the action */ Elf64_Xword r_info; /* index and type of relocation */} Elf64_Rel; typedef struct elf32_rela{ Elf32_Addr r_offset; Elf32_Word r_info; Elf32_Sword r_addend;} Elf32_Rela; typedef struct elf64_rela { Elf64_Addr r_offset; /* Location at which to apply the action */ Elf64_Xword r_info; /* index and type of relocation */ Elf64_Sxword r_addend; /* Constant addend used to compute value */} Elf64_Rela; typedef struct elf32_sym{ Elf32_Word st_name; Elf32_Addr st_value; Elf32_Word st_size; unsigned char st_info; unsigned char st_other; Elf32_Half st_shndx;} Elf32_Sym; typedef struct elf64_sym { Elf64_Word st_name; /* Symbol name, index in string tbl */ unsigned char st_info; /* Type and binding attributes */ unsigned char st_other; /* No defined meaning, 0 */ Elf64_Half st_shndx; /* Associated section index */ Elf64_Addr st_value; /* Value of the symbol */ Elf64_Xword st_size; /* Associated symbol size */} Elf64_Sym; #define EI_NIDENT 16 typedef struct elf32_hdr{ unsigned char e_ident[EI_NIDENT]; Elf32_Half e_type; Elf32_Half e_machine; Elf32_Word e_version; Elf32_Addr e_entry; /* Entry point */ Elf32_Off e_phoff; Elf32_Off e_shoff; Elf32_Word e_flags; Elf32_Half e_ehsize; Elf32_Half e_phentsize; Elf32_Half e_phnum; Elf32_Half e_shentsize; Elf32_Half e_shnum; Elf32_Half e_shstrndx;} Elf32_Ehdr; typedef struct elf64_hdr { unsigned char e_ident[EI_NIDENT]; /* ELF &quot;magic number&quot; */ Elf64_Half e_type; Elf64_Half e_machine; Elf64_Word e_version; Elf64_Addr e_entry; /* Entry point virtual address */ Elf64_Off e_phoff; /* Program header table file offset */ Elf64_Off e_shoff; /* Section header table file offset */ Elf64_Word e_flags; Elf64_Half e_ehsize; Elf64_Half e_phentsize; Elf64_Half e_phnum; Elf64_Half e_shentsize; Elf64_Half e_shnum; Elf64_Half e_shstrndx;} Elf64_Ehdr; /* These constants define the permissions on sections in the program header, p_flags. */#define PF_R 0x4#define PF_W 0x2#define PF_X 0x1 typedef struct elf32_phdr{ Elf32_Word p_type; Elf32_Off p_offset; Elf32_Addr p_vaddr; Elf32_Addr p_paddr; Elf32_Word p_filesz; Elf32_Word p_memsz; Elf32_Word p_flags; Elf32_Word p_align;} Elf32_Phdr; typedef struct elf64_phdr { Elf64_Word p_type; Elf64_Word p_flags; Elf64_Off p_offset; /* Segment file offset */ Elf64_Addr p_vaddr; /* Segment virtual address */ Elf64_Addr p_paddr; /* Segment physical address */ Elf64_Xword p_filesz; /* Segment size in file */ Elf64_Xword p_memsz; /* Segment size in memory */ Elf64_Xword p_align; /* Segment alignment, file &amp; memory */} Elf64_Phdr; typedef struct elf32_shdr { Elf32_Word sh_name; Elf32_Word sh_type; Elf32_Word sh_flags; Elf32_Addr sh_addr; Elf32_Off sh_offset; Elf32_Word sh_size; Elf32_Word sh_link; Elf32_Word sh_info; Elf32_Word sh_addralign; Elf32_Word sh_entsize;} Elf32_Shdr; typedef struct elf64_shdr { Elf64_Word sh_name; /* Section name, index in string tbl */ Elf64_Word sh_type; /* Type of section */ Elf64_Xword sh_flags; /* Miscellaneous section attributes */ Elf64_Addr sh_addr; /* Section virtual addr at execution */ Elf64_Off sh_offset; /* Section file offset */ Elf64_Xword sh_size; /* Size of section in bytes */ Elf64_Word sh_link; /* Index of another section */ Elf64_Word sh_info; /* Additional section information */ Elf64_Xword sh_addralign; /* Section alignment */ Elf64_Xword sh_entsize; /* Entry size if section holds table */} Elf64_Shdr; //android-platform\\bionic\\linker\\linker_soinfo.htypedef void (*linker_dtor_function_t)();typedef void (*linker_ctor_function_t)(int, char**, char**); #if defined(__work_around_b_24465209__)#define SOINFO_NAME_LEN 128#endif struct soinfo {#if defined(__work_around_b_24465209__) char old_name_[SOINFO_NAME_LEN];#endif const ElfW(Phdr)* phdr; size_t phnum;#if defined(__work_around_b_24465209__) ElfW(Addr) unused0; // DO NOT USE, maintained for compatibility.#endif ElfW(Addr) base; size_t size; #if defined(__work_around_b_24465209__) uint32_t unused1; // DO NOT USE, maintained for compatibility.#endif ElfW(Dyn)* dynamic; #if defined(__work_around_b_24465209__) uint32_t unused2; // DO NOT USE, maintained for compatibility uint32_t unused3; // DO NOT USE, maintained for compatibility#endif soinfo* next; uint32_t flags_; const char* strtab_; ElfW(Sym)* symtab_; size_t nbucket_; size_t nchain_; uint32_t* bucket_; uint32_t* chain_; #if !defined(__LP64__) ElfW(Addr)** unused4; // DO NOT USE, maintained for compatibility#endif #if defined(USE_RELA) ElfW(Rela)* plt_rela_; size_t plt_rela_count_; ElfW(Rela)* rela_; size_t rela_count_;#else ElfW(Rel)* plt_rel_; size_t plt_rel_count_; ElfW(Rel)* rel_; size_t rel_count_;#endif linker_ctor_function_t* preinit_array_; size_t preinit_array_count_; linker_ctor_function_t* init_array_; size_t init_array_count_; linker_dtor_function_t* fini_array_; size_t fini_array_count_; linker_ctor_function_t init_func_; linker_dtor_function_t fini_func_; /*#if defined (__arm__) // ARM EABI section used for stack unwinding. uint32_t* ARM_exidx; size_t ARM_exidx_count;#endif size_t ref_count_;// 怎么找不 link_map 这个类型的声明... link_map link_map_head; bool constructors_called; // When you read a virtual address from the ELF file, add this //value to get the corresponding address in the process' address space. ElfW (Addr) load_bias; #if !defined (__LP64__) bool has_text_relocations;#endif bool has_DT_SYMBOLIC;*/}; 按Y将该函数类型改成so 好看多了，但看着还是有点奇怪，可能这个soinfo被魔改过了 交叉引用一下，来到上一个函数，有这样一个函数，我们点进去看看 最终来到这个地方 有一个很可疑的点是v5往上加了0x38 在ELF文件中，32 位 ELF 文件程序头大小是 0x20（32 字节），64 位 ELF 文件程序头大小是 0x38（56 字节） 这里正好就是0x38，所以这里可能就在加载程序头了。 既然要加载程序头，那么在加载之前肯定需要解密，往上引用一下，最后又来到这里，有点眼熟 还记得之前拿到的执行流么，从7000，即加载程序头的函数开始，往上找一找 在50E0的位置发现这里加载了一些东西 继续往上翻，在7240的位置填入了一个地址进去 去那个地址看一眼，AUV，这不rc4么 上面那个则是初始化算法 直接hook出sbox ‍","link":"/2025/07/25/360%E5%8A%A0%E5%9B%BA%E4%BF%9D%E5%85%8D%E8%B4%B9%E7%89%88/"},{"title":"安卓Native层函数注册","text":"当执行一个 Java 的 native 方法时，虚拟机是怎么知道该调用 so 中的哪个方法呢？这就需要用到注册的概念了，通过注册，将指定的 native 方法和 so 中对应的方法绑定起来（函数映射表），这样就能够找到相应的方法了。注册分为 静态注册 和 动态注册两种。默认的实现方式即静态注册 静态注册Java 方法与 C 函数通过名字规则自动对应，C/C++ 的函数名必须严格遵循命名规范： 1Java_包名_类名_方法名(JNIEnv* env, jobject obj, ...) 例子12345678package com.example;public class MyClass { public native void sayHello(); static { System.loadLibrary(&quot;native-lib&quot;); }} native代码 1234567#include &lt;jni.h&gt;#include &lt;stdio.h&gt;JNIEXPORT void JNICALLJava_com_example_MyClass_sayHello(JNIEnv* env, jobject obj) { printf(&quot;Hello from C!\\n&quot;);} 逆向在Java层可以看到Native层注册的函数 在Native层中，可以看到注册的函数，遵循静态注册的命名规则 ‍ 动态注册在本地库加载时（通常在 JNI_OnLoad()），或者在运行时由 C/C++ 代码主动调用 RegisterNatives()，把一组 Java 方法名 + 方法签名 + 本地函数指针 映射注册到 JVM，从而让 Java 代码调用这些本地实现。它不依赖函数名的固定命名规则（Java_package_Class_method）手动把Java方法和C函数的对应关系注册到JVM ​JNI_OnLoad(JavaVM* vm, void* reserved) 在 native-lib 被 System.loadLibrary() 时调用 例子12345678910111213package com.example;public class MyClass { static { System.loadLibrary(&quot;native-lib&quot;); } // Java 声明（实例方法） public native void sayHello(); public native int add(int a, int b); public static native String staticEcho(String s);} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// file: native_reg.c#include &lt;jni.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;// 如果是 C++ 编译器，防止函数名被 mangling#ifdef __cplusplusextern &quot;C&quot; {#endif// -------------------- 本地实现函数 --------------------// 实例方法（对应 Java 的非 static native 方法）static void native_sayHello(JNIEnv* env, jobject thiz) { // 简单打印 —— 注意：Android 上用 printf 可能看不到，建议用 __android_log_print printf(&quot;native_sayHello invoked\\n&quot;);}// 实例方法：带返回值与参数static jint native_add(JNIEnv* env, jobject thiz, jint a, jint b) { return a + b;}// 静态方法（对应 Java 的 static native 方法）注意第二个参数类型是 jclassstatic jstring native_staticEcho(JNIEnv* env, jclass clazz, jstring js) { const char* s = (*env)-&gt;GetStringUTFChars(env, js, NULL); if (s == NULL) { // OOM or other error return NULL; } // 这里可以处理字符串，演示直接返回一个新字符串 jstring ret = (*env)-&gt;NewStringUTF(env, s); (*env)-&gt;ReleaseStringUTFChars(env, js, s); return ret;}// -------------------- 方法表：Java 名称、签名、C 函数指针 --------------------static JNINativeMethod methods[] = { // { &quot;Java 方法名&quot;, &quot;JNI 签名&quot;, (void*)本地函数指针 } {&quot;sayHello&quot;, &quot;()V&quot;, (void*)native_sayHello}, {&quot;add&quot;, &quot;(II)I&quot;, (void*)native_add}, {&quot;staticEcho&quot;, &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;, (void*)native_staticEcho}};// 辅助：计算方法表大小static const int methods_count = sizeof(methods) / sizeof(methods[0]);// -------------------- 注册函数（封装 RegisterNatives） --------------------static int register_native_methods(JNIEnv* env) { // 注意：这里的类路径使用斜杠，不使用点号 const char* kClassPathName = &quot;com/example/MyClass&quot;; jclass clazz = (*env)-&gt;FindClass(env, kClassPathName); if (clazz == NULL) { // 如果 FindClass 失败，打印并清理异常（如果有） if ((*env)-&gt;ExceptionCheck(env)) { (*env)-&gt;ExceptionDescribe(env); (*env)-&gt;ExceptionClear(env); } return JNI_FALSE; } // RegisterNatives 返回 &lt; 0 表示失败 if ((*env)-&gt;RegisterNatives(env, clazz, methods, methods_count) &lt; 0) { if ((*env)-&gt;ExceptionCheck(env)) { (*env)-&gt;ExceptionDescribe(env); (*env)-&gt;ExceptionClear(env); } return JNI_FALSE; } // 如果你需要长期引用这个 jclass，应该创建全局引用： // jclass globalClazz = (*env)-&gt;NewGlobalRef(env, clazz); // 然后存储 globalClazz 供以后使用，并在卸载时 DeleteGlobalRef。 return JNI_TRUE;}// -------------------- JNI_OnLoad：库被 System.loadLibrary 时 JVM 调用 --------------------JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved) { JNIEnv* env = NULL; // 获取 JNIEnv 指针 —— 注意线程安全与返回值检查 if ((*vm)-&gt;GetEnv(vm, (void**)&amp;env, JNI_VERSION_1_6) != JNI_OK) { return JNI_ERR; // 表示加载失败 } // 注册 native 方法（通常在这里做，但 Android 情况见后文） if (!register_native_methods(env)) { return JNI_ERR; // 注册失败，返回错误使加载失败 } // 返回所支持的 JNI 版本 return JNI_VERSION_1_6;}#ifdef __cplusplus} // extern &quot;C&quot;#endif 注意，这里的register_native_methods并不是必须要写的，它的作用只是让代码结构更清晰 一个典型的辅助函数 1234567891011static int register_native_methods(JNIEnv* env, const char* className, JNINativeMethod* methods, int numMethods) { jclass clazz = (*env)-&gt;FindClass(env, className); if (clazz == NULL) { return JNI_FALSE; } if ((*env)-&gt;RegisterNatives(env, clazz, methods, numMethods) &lt; 0) { return JNI_FALSE; } return JNI_TRUE;} 而Jni_Onload是必须的 在Java层执行system.loadLibrary的时候被Jvm自动调用，当 native 库被加载时，完成初始化，比如注册 native 函数。 JNI_OnLoad的标准写法 123456789101112131415161718JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved){ JNIEnv* env = NULL; // 1. 获取 JNIEnv 指针 if ((*vm)-&gt;GetEnv(vm, (void**)&amp;env, JNI_VERSION_1_6) != JNI_OK) { return JNI_ERR; } // 2. 调用自己写的注册函数（可选） if (!register_native_methods(env, &quot;com/example/MyClass&quot;, methods, sizeof(methods) / sizeof(methods[0]))) { return JNI_ERR; } // 3. 返回 JNI 版本号（必须） return JNI_VERSION_1_6;} 在动态注册中，核心函数是 1jint RegisterNatives(JNIEnv* env, jclass clazz, const JNINativeMethod* methods, jint nMethods); 注意，这个methods参数，是一个数组，类型为 12345typedef struct { const char* name; // Java 方法名 const char* signature; // Java 方法签名（描述参数与返回值类型） void* fnPtr; // 对应的 C 函数指针} JNINativeMethod; 如果不传这个表，RegisterNatives()就不知道在注册什么东西 所以也就是说，从逻辑上来看，方法表是一个必须的东西 方法表的结构如下 1234static JNINativeMethod methods[] = { {&quot;sayHello&quot;, &quot;()V&quot;, (void*)native_sayHello}, {&quot;add&quot;, &quot;(II)I&quot;, (void*)native_add}}; “sayHello”这个字段表示函数名 “()V”这个字段表示void (void*)native_sayHello字段表示函数地址 第二个字段的常见签名方法如下 Java 类型 -&gt; JNI 签名 ​void -&gt; V​ ​boolean -&gt; Z​ ​byte -&gt; B​ ​char -&gt; C​ ​short -&gt; S​ ​int -&gt; I​ ​long -&gt; J​ ​float -&gt; F​ ​double -&gt; D​ ​Object -&gt; Lfull/package/ClassName; （包名用 /，例如 Ljava/lang/String;） ​int[] -&gt; [I、String[] -&gt; [Ljava/lang/String;​ 举例： ​void foo() -&gt; ()V​ ​int sum(int a, int b) -&gt; (II)I​ ​String process(String s, int[] arr) -&gt; (Ljava/lang/String;[I)Ljava/lang/String;​ ‍ 逆向同样可以看到注册了个native函数 到了native层，可以发现大不同了 首先可以看到JNI_Onload函数，看不到静态注册格式命名的函数名了 那么应该怎样看动态注册了哪些函数呢 还记得吗，在源码中，我们是写了一个“函数表”的 在IDA中，如果没去符号表，是可以看到的 我们点进去，就可以看到动态注册了哪些函数了 ‍","link":"/2025/10/15/Native%E5%87%BD%E6%95%B0%E6%B3%A8%E5%86%8C/"},{"title":"Frida操作大全","text":"Frida Labs全解 Frida labs参数解释12345-U 指定USB设备-f 指定app包名，通过spawn方式启动（就是重新启动的意思）-P 指定APP的pid--no-pause 不暂停-l 加载hook脚本 ‍ 0x1 Hook修改被调用的方法的逻辑，返回值，传入参数使用随机数，对输入进行判断，如果输入数的满足一个表达式，就会打印出flag 于是这里就有两种思路了。第一种是 hook get_random 函数，让该函数的返回值变成一个固定的值，从而计算表达式的值 第二种思路是 hook check 函数，直接将我们自己定义的值传入进去 12345678910111213141516171819202122232425function hook() { var MainActivity = Java.use(&quot;com.ad2001.frida0x1.MainActivity&quot;); //使用 Frida 的 Java.use() 方法获取目标类 MainActivity 的引用。 MainActivity.get_random.implementation = function () { //implementation 在 Frida 中是一个关键属性，用于覆盖原始 Java 方法的实现 return 0; }}function hook2() { var MainActivity = Java.use(&quot;com.ad2001.frida0x1.MainActivity&quot;); MainActivity.check.overload('int', 'int').implementation = function (a, b) { //overload用于指定参数，由于Java的方法可以重载，所以需要指定 console.log(&quot;Origin i and i2 = &quot;, a, b); //console.log打印 return this.check(3, b); //我们自己将 i 的值定为 3 传入进去 }}function main() { Java.perform(function () { hook2(); })}setImmediate(main); 注入 1frida -U -f com.ad2001.frida0x1 -l hook.js -U -f 缺一不可 为什么 缺少 -f 12345678910111213C:\\Users\\29660\\Desktop\\Frida\\Frida-Labs-main\\Frida-Labs-main\\Frida 0x1&gt;frida -U com.ad2001.frida0x1 -l hook.js ____ / _ | Frida 16.4.10 - A world-class dynamic instrumentation toolkit | (_| | &gt; _ | Commands: /_/ |_| help -&gt; Displays the help system . . . . object? -&gt; Display information about 'object' . . . . exit/quit -&gt; Exit . . . . . . . . More info at https://frida.re/docs/home/ . . . . . . . . Connected to Android Emulator 5554 (id=emulator-5554)Failed to spawn: unable to find process with name 'com.ad2001.frida0x1' Failed to spawn: unable to find process with name ‘com.ad2001.frida0x1’表示没有Frida 找不到名为 ​com.ad2001.frida0x1​ 的进程，详见lab02 ‍ 缺少-U 12345678910111213C:\\Users\\29660\\Desktop\\Frida\\Frida-Labs-main\\Frida-Labs-main\\Frida 0x1&gt;frida -f com.ad2001.frida0x1 -l hook.js ____ / _ | Frida 16.4.10 - A world-class dynamic instrumentation toolkit | (_| | &gt; _ | Commands: /_/ |_| help -&gt; Displays the help system . . . . object? -&gt; Display information about 'object' . . . . exit/quit -&gt; Exit . . . . . . . . More info at https://frida.re/docs/home/ . . . . . . . . Connected to Local System (id=local)Failed to spawn: unable to find executable at 'com.ad2001.frida0x1' 说明 Frida 没有连接到 Android 模拟器，而是连接到了你本地电脑（Windows），所以它以为是要在本地运行一个叫 com.ad2001.frida0x1 的可执行文件。 ‍ 0x2 Hook调用静态的未被调用的方法可以看到这里定义了一个 get_flag 方法，但是并没有在主函数中被调用 使用 frida 直接调用未被调用的静态方法 12345678910111213141516171819202122232425setImmediate(function () { Java.perform(function () { var a = Java.use(&quot;com.ad2001.frida0x2.MainActivity&quot;) a.get_flag(4919); })})function hook() { var MainActivity = Java.use(&quot;com.ad2001.frida0x2.MainActivity&quot;); MainActivity.get_flag(4919);}function main() { Java.perform(function () { hook(); })}setImmediate(main); hook的时候使用如下命令有可能会hook不上 1frida -U -f com.ad2001.frida0x2 -l hook.js 原因是setImmediate(main);是程序启动后立即注入，可能会导致程序还没完全启动就注入了，所以hook不上 解决办法是使用 1frida -U 'frida 0x2' -l hook.js 那么，为什么将frida 0x2写成包名com.ad2001.frida0x2就不行呢 1frida -U com.ad2001.frida0x2 -l hook.js 这个命令尝试的是：根据包名注入，默认是 spawn（启动）模式。 实际上这条命令是尝试 spawn（启动）包名对应的 app，但没写 -f，它又不是 attach 模式，就会失败。 或者将hook代码中的 setImmediate(main);改成 setTimeout(main,1000);延迟启动 12345678910111213function hook() { var MainActivity = Java.use(&quot;com.ad2001.frida0x2.MainActivity&quot;); MainActivity.get_flag(4919);}function main() { Java.perform(function () { hook(); })}// setImmediate(main);setTimeout(main, 1000); ‍ 0x3 更改类中的静态变量hook code的值 1234567891011121314function hook() { var a = Java.use(&quot;com.ad2001.frida0x3.Checker&quot;) //code的值在Checker类里 a.code.value = 512; //使用这一句修改静态变量的值}function main() { Java.perform(function () { hook(); })}setImmediate(main); 思考： a是什么 a.code.value具体是什么意思 以下内容来自GPT 在这段 Frida 脚本中： 1var a = Java.use(&quot;com.ad2001.frida0x3.Checker&quot;) a 是什么？👉 ​a​ 是一个 Frida 创建的 Java 类代理对象（Java class wrapper） ，你可以把它当成是一个“控制器”或者“代理”，用来访问和操作 Java 中的类 com.ad2001.frida0x3.Checker 的静态字段、静态方法、实例方法，甚至可以 hook 它的方法。 类比一下：在 Java 代码中你可能会这样用一个类： 1Checker.code = 512; 在 Frida 中，为了达到类似的效果，我们写： 12var a = Java.use(&quot;com.ad2001.frida0x3.Checker&quot;)a.code.value = 512; 更具体地说： ​Java.use(&quot;...&quot;) 会返回一个 Frida 的 Java 类接口（wrapper） 这个对象不是类的一个实例，而是一个可以操作 类本身（静态成员）或创建实例 的对象。 如果你需要创建类的实例，你可以这样写： 1var instance = a.$new(); // 等于 Java 里的 new Checker() 所以总结一下： 名称 解释 ​a​ Frida 中的类包装对象，表示Checker类 ​a.code.value​ 表示访问并修改类中code这个静态字段的值 ​a.$new()​ （可选）表示创建这个类的一个新实例 ‍ 0x4 调用非MainActivity,非静态方法​MainActivity里没有任何东西 定义了一个Check类，里面有get_flag方法 想调用这个get_flag方法，必须实例化一个check类对象，在frida中可以用以下脚本实现 123456789101112131415161718function hook() { var c = Java.use(&quot;com.ad2001.frida0x4.Check&quot;); var c_check = c.$new(); //实例化check类对象 相当于Java里写 c c_check = new c(); var flag = c_check.get_flag(1337); console.log(flag);}function main() { Java.perform(function () { hook(); })}setImmediate(main); 运行结果如下 0x5 调用MainActivity中的非静态方法在 0x2 中，我们使用frida调用了静态方法 但在本次，这是一个非静态方法 Java中静态方法可以直接调用，而非静态方法必须实例化一个对象之后才能调用 123456789101112131415161718192021public class Hello { // 静态方法 public static void sayStatic() { System.out.println(&quot;我是静态方法&quot;); } // 非静态方法 public void sayInstance() { System.out.println(&quot;我是非静态方法&quot;); } public static void main(String[] args) { // 调用静态方法：不需要创建对象 Hello.sayStatic(); // 调用非静态方法：必须先创建对象 Hello h = new Hello(); h.sayInstance(); }} 我们直接用 0x2 的脚本hook一下 123456789101112function hook() { var MainActivity = Java.use(&quot;com.ad2001.frida0x5.MainActivity&quot;); MainActivity.flag(1337);}function main() { Java.perform(function () { hook(); })}setImmediate(main); 哦豁，报错了 以下解释来自SWDD师傅 直接使用Frida创建MainActivity或任何Android组件可能会很棘手，因为Android的生命周期和线程规则。Android组件，如Activity子类，依赖于应用程序上下文进行正确运行。在Frida中，您可能缺少必要的上下文。Android UI组件通常需要具有关联Looper的特定线程。如果涉及UI任务，请确保在具有活动Looper的主线程上执行。活动是较大的Android应用程序生命周期的一部分。创建MainActivity的实例可能需要应用处于特定状态，并且通过Frida管理整个生命周期可能并不直接。总之，为MainActivity创建实例并不是一个好主意。 通俗点来说就是， 用Frida直接创建 MainActivity 或其他 Android 组件（比如 Activity）是很麻烦的，甚至是不可行的。 原因是这样的： Activity 需要上下文（Context）才能正常工作：就像你造房子要有地基一样，Activity 这种组件运行的时候，需要依赖应用程序提供的运行环境（就是 Context）。在 Frida 里，你是“旁观者”，而不是“房子的主人”，所以没法轻松提供这个环境。 UI 相关的代码必须在主线程（带 Looper 的线程）里跑：Android 要求所有跟界面有关的操作都得在“主线程”里运行，这个线程有个叫 Looper 的消息循环系统。在 Frida 里，如果你随便在哪个线程里跑 UI 代码，程序很可能直接崩掉。 Activity 的生命周期很复杂：系统会自动帮 Activity 调用一系列方法，比如 onCreate、onStart、onResume 等。这一整套流程是系统控制的。如果你自己用 Frida 去“强行”创建一个 Activity 实例，系统其实并不知道它存在，所以它无法正常工作。 那么应该怎么办呢 SWDD说 当Android应用程序启动时，系统会创建MainActivity的一个实例（或AndroidManifest.xml文件中指定的启动器活动）。创建MainActivity实例是Android应用程序生命周期的一部分。因此，我们可以使用frida获取MainActivity的实例，然后调用flag()方法来获取我们的标志。 让我们看看GPT怎么说 📱 正常来说，Android 应用是怎么启动的？ 当你点击某个 App 图标时， Android 系统就会去看这个 App 的 AndroidManifest.xml 文件， 找到标注为「启动入口」的 Activity（比如 MainActivity）， 然后系统会自动创建这个 Activity 的实例，并调用它的一系列生命周期方法（比如 onCreate()、onResume() 等）。 🧠 那这段话的核心意思就是： 你自己不用 new 一个 MainActivity，系统已经帮你创建好了！ 所以与其自己创建一个可能不完整的实例（会有很多问题），不如直接去“拿到”系统已经创建的那个实例，然后调用你想要的函数，比如 ​flag()​ ​ 。 ✅ 总结一下，通俗点说就是： “Android 系统会自动帮你创建 MainActivity 的实例，所以你不需要自己造一个。用 Frida 可以直接找到这个已经存在的实例，然后调用你想要的方法（比如 ​flag()​ ​ ）来拿 flag。” 有这样一个模板 12345678Java.performNow(function() { Java.choose('&lt;包名&gt;.&lt;类名&gt;', { onMatch: function(instance) { // 待办事项 }, onComplete: function() {} });}); onMatch ​onMatch回调函数在Java.choose操作期间找到指定类的每个实例时执行。 这个回调函数接收当前实例作为它的参数。 您可以在onMatch回调中定义自定义操作，以在每个实例上执行。 ​function(instance) {}，instance参数表示目标类的每个匹配实例。您可以使用任何其他名称。参数 instance 就是这个 MainActivity 的对象，你可以在这里调用它的函数，比如 instance.flag()​ onComplete ​onComplete回调在Java.choose操作完成后执行操作或清理任务。此块是可选的，如果您在搜索完成后不需要执行任何特定操作，则可以选择将其留空。 尝试使用该模板寻找MainActivity实例 1234567891011121314151617181920function hook() { Java.choose('com.ad2001.frida0x5.MainActivity', { onMatch: function (instance) { console.log(&quot;Sucess found!!!&quot;); }, onComplete: function () { console.log(&quot;end&quot;); } });}function main() { Java.perform(function () { hook(); })}setImmediate(main); 在这里还发现个问题，当使用如下命令启动frida时，只会打印一个 end ，hook不上，需要重新修改一下脚本（例如注释掉某一行再加上） 1frida -U -f com.ad2001.frida0x5 -l lab05.js 原因其实跟 0x2 一样，由于脚本是立即注入，app还来不及创建MainActivity实例，自然就没找到 解决办法也跟 0x2 一样，这里就不再赘述 ‍ 0x6 MainActivity中的非静态方法且参数通过非MainActivity非静态方法传递MainActivity中的非静态方法 get_flag ，并且参数是通过 Checker 类对象 A 来传递的 Checker类如下 所以这题就是0x5 0x4 0x3的结合，但是在 0x3 中，变量为静态变量，所以需要这里需要创建一个类的对象来对变量进行更改 12345678910111213141516171819202122232425262728293031function hook() { Java.choose(&quot;com.ad2001.frida0x6.MainActivity&quot;, { onMatch: function (MainActivity) { var c = Java.use(&quot;com.ad2001.frida0x6.Checker&quot;) var A = c.$new(); A.num1.value = 1234; A.num2.value = 4321; console.log(&quot;success&quot;); MainActivity.get_flag(A); }, onComplete: function () { console.log(&quot;end&quot;); } });}function main() { Java.perform(function () { hook(); })}// setImmediate(main);setTimeout(main, 1000); ‍ 0x7 Hook构造函数构造函数是 Java 类中的一种特殊方法，它的作用是：在创建对象的时候用来初始化对象的属性。 先举个例子来了解一下森莫是Java中的构造函数 123456789101112131415161718192021222324252627public class Dog { String name; int age; // 构造函数 public Dog(String n, int a) { name = n; age = a; } // 普通方法 public void bark() { System.out.println(name + &quot; 汪汪叫！&quot;); } public void showInfo() { System.out.println(&quot;这只狗叫 &quot; + name + &quot;，它 &quot; + age + &quot; 岁了。&quot;); } public static void main(String[] args) { Dog d = new Dog(&quot;小黑&quot;, 3); // 调用构造函数，初始化对象 Dog（第一个）👉 表示变量 d 的 类型，也就是类名，说明 d 是一个 Dog 类型的对象。 //new Dog(&quot;小黑&quot;, 3)（后面这个）👉 是 调用构造函数，创建一个新的 Dog 对象，并传入两个参数。 d.bark(); // 调用普通方法 d.showInfo(); // 调用普通方法 }} 来看本题，调用了flag方法，并且通过Checker构造函数对 num1 和 num2 赋值为 123 和 321 在Frida中使用 $init 关键字来 hook 构造函数 123456789101112131415161718192021function hook() { var Checker = Java.use(&quot;com.ad2001.frida0x7.Checker&quot;); Checker.$init.implementation = function (a, b) { // Checker.$init 是这个类的 构造函数（constructor）。 // .implementation = function (a, b) 表示你要“劫持”这个构造函数，用你自己的实现来替代原来的。 // a, b 就是原本传给构造函数的两个参数。 console.log(&quot;Origin num&quot;, a, b); this.$init(666, 666); //this.$init(...) 表示“用原本的方式继续初始化对象，但用我给的参数” console.log(&quot;success&quot;); }}function main() { Java.perform(function () { hook(); })}setImmediate(main); 写到这我有点好奇如果使用 0x1 的方法直接去 hook 构造函数会怎样 来吧，实践出真知 1234567891011121314function hook() { var Ch = Java.use(&quot;com.ad2001.frida0x7.Checker&quot;); Ch.Checker.overload('int', 'int').implementation = function (a, b) { console.log(&quot;Origin num&quot;, a, b); //console.log打印 return this.Checker(666, 666); }}function main() { Java.perform(function () { hook(); })}setImmediate(main); 哈哈，报错了，cannot read property ‘overload’ of undefined 说明试图 hook 的 Java 方法并没有找到 然后我又好奇，如果使用 0x3 的方法直接改变 num1 和 num2 会怎样 1234567891011121314151617181920212223function hook() { var Checker = Java.use(&quot;com.ad2001.frida0x7.Checker&quot;); Checker.$init.implementation = function (a, b) { // Checker.$init 是这个类的 构造函数（constructor）。 // .implementation = function (a, b) 表示你要“劫持”这个构造函数，用你自己的实现来替代原来的。 // a, b 就是原本传给构造函数的两个参数。 console.log(&quot;Origin num&quot;, a, b); // this.$init(666, 666); //this.$init(...) 表示“用原本的方式继续初始化对象，但用我给的参数” Checker.num1.value = 666; Checker.num2.value = 666; console.log(&quot;success&quot;); }}function main() { Java.perform(function () { hook(); })}setImmediate(main); 哈哈，果然又报错了 Error: Cannot access an instance field without an instance 表示试图访问 Checker.num1，但这是 实例字段（成员变量） ，你必须通过一个具体对象（也就是 this）来访问它 改成这样或许会比初代脚本好理解一些，跟 0x1 也更像 1234567891011121314151617181920212223function hook() { var Checker = Java.use(&quot;com.ad2001.frida0x7.Checker&quot;); Checker.$init.overload('int', 'int').implementation = function (a, b) { console.log(&quot;Origin num:&quot;, a, b); // 调用原始构造函数初始化对象 this.$init(a, b); // 修改成员变量 this.num1.value = 666; this.num2.value = 666; console.log(&quot;Success: num1 and num2 changed to 666&quot;); };}function main() { Java.perform(function () { hook(); })}setImmediate(main); ‍ 0x8 Hook Native层中调用的函数并且读取传入的参数从本章开始进入 Native层 模板如下 12345678910Interceptor.attach(targetAddress, { onEnter: function (args) { console.log('Entering ' + functionName); // Modify or log arguments if needed }, onLeave: function (retval) { console.log('Leaving ' + functionName); // Modify or log return value if needed }}); 它的作用是： 当程序运行到某个特定函数（地址为 ​targetAddress​​ ）时： 函数刚进入时（onEnter） ：打印一句话，说“我进来了”； 函数执行完返回时（onLeave） ：再打印一句“我出去了”。 每行的意思 1Interceptor.attach(targetAddress, { 用 Frida 的 Interceptor.attach 来拦截（hook）某个函数地址。这个地址是你想观察或修改的函数位置（targetAddress）。 1234onEnter: function (args) { console.log('Entering ' + functionName); // Modify or log arguments if needed}, 当程序刚进入这个函数时，会执行 onEnter 这个回调。你可以： 打印日志（像现在这样打印“正在进入函数”）； 查看和修改传入参数（args 是参数列表）。 ‍ 1234onLeave: function (retval) { console.log('Leaving ' + functionName); // Modify or log return value if needed} 当函数执行完准备返回时，会执行 onLeave。你可以： 打印返回值； 修改返回值（retval 是返回值）。 ‍ 需要获取targetAddress我们可以使用如下API ​Module.enumerateExports() 通过调用 Module.enumerateExports()，我们可以获取到导出函数的名称、地址以及其他相关信息。这些信息对于进行函数挂钩、函数跟踪或者调用其他函数都非常有用。 ​Module.getExportByName() 当我们知道要查找的导出项的名称但不知道其地址时，可以使用 Module.getExportByName()。通过提供导出项的名称作为参数，这个函数会返回与该名称对应的导出项的地址。 ​Module.findExportByName() 这与 Module.getExportByName() 是一样的。唯一的区别在于，如果未找到导出项，Module.getExportByName() 会引发异常，而 Module.findExportByName() 如果未找到导出项则返回 null​ ​Module.getBaseAddress() 通过调用 Module.getBaseAddress() 函数，我们可以获取指定模块的基址地址，然后可以基于这个基址地址进行偏移计算，以定位模块内部的特定函数、变量或者数据结构 ​Module.enumerateImports() 通过调用 Module.enumerateImports() 函数，我们可以获取到指定模块导入的外部函数或变量的名称、地址以及其他相关信息。 ‍ 使用 Module.enumerateImports(“libfrida0x8.so”) 查看导入表 使用Module.findExportByName(“libc.so”,”strcmp”);来获取strcmp的地址 来看这题 加载了一个 frida0x8 so文件里有一个 strcmp 函数，第二个参数 s2 就是经过处理后的正确的 flag ，所以我们需要把strcmp函数的第二个参数hook出来 我先按照我自己的想法写了一个脚本 1234567891011121314151617181920212223function hook() { var target = Module.findExportByName(&quot;libc.so&quot;, &quot;strcmp&quot;); //查找strcmp的地址 console.log(&quot;strcmp addr is :&quot;, target.toString(16)); Interceptor.attach(target, { onEnter: function (args) { console.log(Memory.readUtf8String(args[1])); //打印strcmp的第二个参数 }, onLeave: function (retval) { } })}function main() { Java.perform(function () { hook(); })}setImmediate(main); 输出如下 这里其实是因为，我以为我hook的是特定的某一个strcmp，实际上这个 hook 是生效于所有调用 libc.so!strcmp 的地方，无论是 native 调用还是通过 JNI 被 Java 调用的 native 方法，都会被拦截 所以导致了这种情况 所以要加一个判断，当strcmp的第一个参数包含某个数（例如666）时，就打印第二个参数的结果，使我们的目标更加“精确” 修改脚本如下 1234567891011121314151617181920212223242526272829function hook() { var target = Module.findExportByName(&quot;libc.so&quot;, &quot;strcmp&quot;); //查找strcmp的地址 console.log(&quot;strcmp addr is :&quot;, target.toString(16)); Interceptor.attach(target, { onEnter: function (args) { //args只是我对参数起的名字，可以改成任何别的 var input = Memory.readUtf8String(args[0]); if (input.includes(&quot;666&quot;)) { console.log(Memory.readUtf8String(args[1])); //打印strcmp的第二个参数 } }, onLeave: function (retval) { } })}function main() { Java.perform(function () { hook(); })}setImmediate(main); 在 Frida 中： ​Memory 是 Frida 的一个全局对象，提供了访问目标进程内存的方法。 它可以用来： 读取内存（如 Memory.readUtf8String(ptr)、Memory.readByteArray(ptr, size)） 写入内存（如 Memory.writeUtf8String(ptr, &quot;hello&quot;)） 你用的 Memory.readUtf8String() 是它最常用的函数之一，专门处理 C 字符串（以 null 结尾的 UTF-8 字符串）。 ‍ 0x9 Hook Native层函数的返回值check_flag的值如果是1337就打印flag native层中的该函数的返回值是1 修改该函数的返回值即可 12345678910111213141516171819202122232425function hook() { var target = Module.enumerateExports(&quot;liba0x9.so&quot;)[0][&quot;address&quot;]; console.log(&quot;addr is :&quot;, target); Interceptor.attach(target, { onEnter: function (args) { }, onLeave: function (retval) { console.log(&quot;Origin retval is :&quot;, retval); retval.replace(1337); } })}function main() { Java.perform(function () { hook(); })}setImmediate(main); 思考： 这一句 1var target = Module.enumerateExports(&quot;liba0x9.so&quot;)[0][&quot;address&quot;]; 在 0x8 中使用的是 1var target = Module.findExportByName(&quot;libc.so&quot;, &quot;strcmp&quot;); 我的猜想是，在 0x8 中，我们使用 Module.enumerateImports(“libfrida0x8.so”)查看导入表，而在该题目中，由于hook的是自己的函数，所以需要使用Module.enumerateExports(“liba0x9.so”)查看导出表 导入表（Imports） ：是这个库 调用别人的函数，通常是系统函数，比如 libc.so 里的 malloc、printf、strlen 等。 导出表（Exports） ：是这个库 暴露给别人用的函数，很多时候是你自己写的，比如 Java_com_example_myapp_NativeMethod 这种 native 接口，或者一些插件调用的入口函数。 查看导出表 尝试改成跟 0x8 中差不多的写法 1var target = Module.findExportByName(&quot;liba0x9.so&quot;, &quot;Java_com_ad2001_a0x9_MainActivity_check_1flag&quot;); 好吧这样也可以，实践出真知了 还是解释一下这一句吧 1var target = Module.enumerateExports(&quot;liba0x9.so&quot;)[0][&quot;address&quot;]; ​Module.enumerateExports(&quot;liba0x9.so&quot;)这会列出 liba0x9.so 这个 native 库里导出的所有函数（也就是那些对外开放可以调用的函数），返回一个包含信息的数组，比如： 12345[ {name: &quot;check_flag&quot;, address: ptr(&quot;0x12345678&quot;), type: &quot;function&quot;}, {name: &quot;init&quot;, address: ptr(&quot;0x12345690&quot;), type: &quot;function&quot;}, ...] ​[0][&quot;address&quot;]表示取这个导出函数列表里的第一个函数的地址，也就是 check_flag 的地址（假设第一个刚好是它）。这一行把这个地址赋值给 check_flag 变量。[0]表示索引 ‍ 0xA Hook Native层未被调用的方法从本章开始使用模拟器会闪退，这里使用的环境是Redmi K60 安卓14 已ROOT 可以使用如下模板 123var native_adr = new NativePointer(&lt;address_of_the_native_function&gt;);const native_function = new NativeFunction(native_adr, '&lt;return type&gt;', ['argument_data_type']);native_function(&lt;arguments&gt;); ‍ 让我们来逐行解释一下 1var native_adr = new NativePointer(&lt;address_of_the_native_function&gt;); 这一句的意思是，我们知道一个原生函数在内存中的地址（比如 0x12345678），把它封装成一个 NativePointer 类型的对象，好让 Frida 能识别这个地址。&lt;address_of_the_native_function&gt; 是手动填进去的地址，通常是通过逆向分析（IDA、Frida hook 等）找到的函数地址。 ‍ 1const native_function = new NativeFunction(native_adr, '&lt;return type&gt;', ['argument_data_type']); 这一行的意思是，把这个地址（native_adr）对应的函数转换成 JavaScript 能调用的函数。 ​&lt;return type&gt; 表示这个函数的返回值类型，比如 'int'、'void'、'pointer' 等。 ​['argument_data_type'] 表示这个函数的参数类型列表，比如 ['int', 'pointer']。 所以这一行的作用是：用 Frida 的 ​NativeFunction​ 包装原生函数，让你可以像普通 JS 函数那样去调用它。 ‍ 1native_function(&lt;arguments&gt;); 最后直接调用这个原生函数，传入你需要的参数（这些参数要和上面声明的参数类型匹配） 现在来看看例题 Java层并不能看到什么有用的，只是加载了stringFromJNI()​ 我们来看看native层，stringFromJNI也没什么有用的信息，但是有一个get_flag函数可以打印flag 于是思路就是，利用上面的模板 hook 出get_flag函数 模仿 0x9 中使用 Module.enumerateExports(“libfrida0xa.so”) 查看导出表，发现导出表非常之长，直接使用var target = Module.enumerateExports(“liba0x9.so”)[0][“address”];进行索引会有点麻烦，所以我们换一种方法 由于ALSR（地址随机化）的问题，所以我们先使用Module.findBaseAddress(&quot;libfrida0xa.so&quot;);查看一下基地址 可以构造如下循环 1234567891011121314151617var base_addr = Module.findBaseAddress(&quot;libfrida0xa.so&quot;); var exports = Module.enumerateExports(&quot;libfrida0xa.so&quot;); var target = null;for (var i = 0; exports[i] != null; i++){ if (exports[i][&quot;name&quot;] == &quot;_Z8get_flagii&quot;) { console.log(&quot;function get_flag : &quot;, exports[i][&quot;address&quot;]); console.log((exports[i][&quot;address&quot;] - base_addr).toString(16)); target = exports[i][&quot;address&quot;]; } } 这里我们找到基地址后，遍历导出表，如果在导出表中找到了 get_flag 函数，就打印出 get_flag 函数的绝对地址 同时由于我们知道了绝对地址和基地址，于是我们就可以顺便把偏移地址也打印出来 偏移 = 函数地址 - 模块基地址 这样我们就找到了我们需要 hook 的目标函数的地址 ‍ 这里还有个问题，为什么 get_flag 要写成 “_Z8get_flagii” 呢 这其实是C++ 的 name mangling（名字改编 / 名字重整）问题 什么是 Name Mangling？ 在 C++ 中，函数名会被编译器自动改写成一串带有额外信息的名字，称为 mangled name（重整名字） 。 这是因为 C++ 支持函数重载（同名函数，不同参数） ，而汇编语言、链接器、操作系统等底层东西并不支持这一特性。 举个例子： 12int add(int a, int b);float add(float a, float b); 这两个函数在 C++ 中是合法的，因为它们参数不同。但如果你不做 name mangling，它们在汇编/符号表里都叫 add，系统就不知道你到底想调用哪个。 所以编译器会把它们改名： 12int add(int, int) --&gt; _Z3addiifloat add(float, float) --&gt; _Z3addff 这就是 name mangling。 由于我们主要研究frida hook，这个问题就不过多赘述 ‍ 回归正题，知道了我们的目标地址后就可以直接写脚本啦，利用上面的模板 12345678910111213141516171819202122232425262728293031323334353637function hook() { var base_addr = Module.findBaseAddress(&quot;libfrida0xa.so&quot;); var exports = Module.enumerateExports(&quot;libfrida0xa.so&quot;); var target = null; for (var i = 0; exports[i] != null; i++){ if (exports[i][&quot;name&quot;] == &quot;_Z8get_flagii&quot;) { console.log(&quot;function get_flag : &quot;, exports[i][&quot;address&quot;]); console.log(&quot;base addr is:&quot;, (exports[i][&quot;address&quot;] - base_addr).toString(16)); target = exports[i][&quot;address&quot;]; } } var get_flag_ptr = new NativePointer(target); const My_get_flag = new NativeFunction(get_flag_ptr, 'char', ['int', 'int']); var flag = My_get_flag(1, 2); console.log(flag);}function main() { Java.perform(function () { hook(); })}setImmediate(main) 由于打印出的是函数的返回值，而且so文件中使用的函数是__android_log_print，所以flag在logcat中可以看到 思考：能否直接在frida面板中打印出flag？ 有的兄弟，有的 还记得lab0x8的内容吗，我们可以Hook __android_log_print这个函数，直接截获 flag flag的内容是__android_log_print的第四个参数，所以我们直接读取它的第四个参数然后打印出来就行 完整hook并打印flag的脚本如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function hook() { var base_addr = Module.findBaseAddress(&quot;libfrida0xa.so&quot;); var exports = Module.enumerateExports(&quot;libfrida0xa.so&quot;); var target = null; for (var i = 0; exports[i] != null; i++){ if (exports[i][&quot;name&quot;] == &quot;_Z8get_flagii&quot;) { console.log(&quot;function get_flag : &quot;, exports[i][&quot;address&quot;]); console.log(&quot;base addr is:&quot;, (exports[i][&quot;address&quot;] - base_addr).toString(16)); target = exports[i][&quot;address&quot;]; } } var get_flag_ptr = new NativePointer(target); const My_get_flag = new NativeFunction(get_flag_ptr, 'char', ['int', 'int']); var print_addr = Module.findExportByName(null, &quot;__android_log_print&quot;); //hook __android_log_print函数 Interceptor.attach(print_addr, { onEnter: function (args) { var flagPtr = args[3]; var flag = flagPtr.readCString(); console.log(flag); //读取并打印flag内容 }, onLeave: function (retval) { } }); var flag = My_get_flag(1, 2); console.log(flag);}function main() { Java.perform(function () { hook(); })}setImmediate(main) ‍ 0xB 更改Native层的汇编指令先来看x86下的模板 12345678910var writer = new X86Writer(opcodeaddr);Memory.protect(opcodeaddr, 0x1000, &quot;rwx&quot;);try { writer.flush(); } finally { writer.dispose();} 我们来解释一下 1var writer = new X86Writer(opcodeaddr); 创建了一个写指令的“写手”对象，叫 writer。 ​X86Writer 是 Frida 提供的一个类，用来向指定内存地址写入 x86 汇编指令。 ​opcodeaddr 是你想修改的地址，比如某个函数开头或者中间的指令地址。 1emory.protect(opcodeaddr, 0x1000, &quot;rwx&quot;); 把从 opcodeaddr 开始的一段内存（大小为 0x1000 字节，也就是一页）设置为可读（r）、可写（w）、可执行（x）。 默认情况下，程序的代码区域一般是只读的；要想修改它，就得先把它“解锁”。 1try { writer.flush(); } try块中我们可以插入要修改/添加的x86指令。X86Writer实例提供了各种方法来插入各种x86指令。 ​writer.flush();​ 插入指令后，调用flush方法将更改应用到内存中。这确保修改后的指令被写入内存位置。 1finally { writer.dispose(); } 最后无论是否出错，都调用 dispose() 来释放资源。否则可能会造成内存泄漏 对于x86而言，我们可以查阅如下文档 JavaScript API | Frida • A world-class dynamic instrumentation toolkit 对于arm64而言，我们可以查阅如下文档 JavaScript API | Frida • A world-class dynamic instrumentation toolkit 接下来让我们看看例题，使用的架构为arm64架构 Java层依旧是什么都没有 native层中的MainActivity伪代码界面什么都没有，很明显这不正常 看看控制流，发现这里构成了一个永假跳转指令，导致我们的IDA反编译出错 那么，我们直接nop掉这个B.NE即可 IDA查看偏移地址是在0x15248处 开始hook 123456789101112131415161718192021222324252627function hook() { var base_addr = Module.getBaseAddress(&quot;libfrida0xb.so&quot;); console.log(&quot;Base address : &quot;, base_addr); var BNE_addr = base_addr.add(0x15248); Memory.protect(base_addr, 0x1000, &quot;rwx&quot;); var writer = new Arm64Writer(BNE_addr); try { writer.putNop(); writer.flush(); console.log(&quot;Success!!&quot;); } finally { writer.dispose(); }}function main() { Java.perform(function () { hook(); })}setTimeout(main, 1000); 同样是需要到logcat中查看flag ‍ ‍ ‍ ‍ ‍ ‍ ‍ ‍ ‍ ‍ ‍ ‍","link":"/2024/04/10/Frida%20labs/"}],"tags":[{"name":"比赛复现","slug":"比赛复现","link":"/tags/%E6%AF%94%E8%B5%9B%E5%A4%8D%E7%8E%B0/"},{"name":"宋词","slug":"宋词","link":"/tags/%E5%AE%8B%E8%AF%8D/"},{"name":"古代散文","slug":"古代散文","link":"/tags/%E5%8F%A4%E4%BB%A3%E6%95%A3%E6%96%87/"},{"name":"移动安全","slug":"移动安全","link":"/tags/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/"}],"categories":[{"name":"逆向","slug":"逆向","link":"/categories/%E9%80%86%E5%90%91/"},{"name":"古文","slug":"古文","link":"/categories/%E5%8F%A4%E6%96%87/"}]}
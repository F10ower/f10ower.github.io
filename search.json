[{"title":"安卓Native层函数注册","url":"/2025/10/15/Native函数注册/","content":"\n当执行一个 Java 的 native 方法时，虚拟机是怎么知道该调用 so 中的哪个方法呢？这就需要用到注册的概念了，通过注册，将指定的 native 方法和 so 中对应的方法绑定起来（函数映射表），这样就能够找到相应的方法了。  \n注册分为 **静态注册 和 动态注册**两种。默认的实现方式即静态注册\n\n<!--more-->\n\n\n\n## 静态注册\n\nJava 方法与 C 函数通过**名字规则**自动对应，C/C++ 的函数名必须严格遵循命名规范：\n\n```python\nJava_包名_类名_方法名(JNIEnv* env, jobject obj, ...)\n```\n\n### 例子\n\n```python\npackage com.example;\n\npublic class MyClass {\n    public native void sayHello();\n    static {\n        System.loadLibrary(\"native-lib\");\n    }\n}\n```\n\nnative代码\n\n```python\n#include <jni.h>\n#include <stdio.h>\n\nJNIEXPORT void JNICALL\nJava_com_example_MyClass_sayHello(JNIEnv* env, jobject obj) {\n    printf(\"Hello from C!\\n\");\n}\n```\n\n### 逆向\n\n在Java层可以看到Native层注册的函数\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20251013205340.png)\n\n在Native层中，可以看到注册的函数，遵循静态注册的命名规则\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20251013205456.png)\n\n‍\n\n## 动态注册\n\n在本地库加载时（通常在 `JNI_OnLoad()`），或者在运行时由 C/C++ 代码主动调用 `RegisterNatives()`，把一组 `Java 方法名 + 方法签名 + 本地函数指针` 映射注册到 JVM，从而让 Java 代码调用这些本地实现。  \n它**不依赖**函数名的固定命名规则（`Java_package_Class_method`）手动把Java方法和C函数的对应关系注册到JVM\n\n​`JNI_OnLoad(JavaVM* vm, void* reserved)` 在 native-lib 被 `System.loadLibrary()` 时调用\n\n### 例子\n\n```java\npackage com.example;\n\npublic class MyClass {\n    static {\n        System.loadLibrary(\"native-lib\");\n    }\n\n    // Java 声明（实例方法）\n    public native void sayHello();\n    public native int add(int a, int b);\n    public static native String staticEcho(String s);\n}\n\n```\n\n```C\n// file: native_reg.c\n#include <jni.h>\n#include <stdio.h>\n#include <string.h>\n\n// 如果是 C++ 编译器，防止函数名被 mangling\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// -------------------- 本地实现函数 --------------------\n// 实例方法（对应 Java 的非 static native 方法）\nstatic void native_sayHello(JNIEnv* env, jobject thiz) {\n    // 简单打印 —— 注意：Android 上用 printf 可能看不到，建议用 __android_log_print\n    printf(\"native_sayHello invoked\\n\");\n}\n\n// 实例方法：带返回值与参数\nstatic jint native_add(JNIEnv* env, jobject thiz, jint a, jint b) {\n    return a + b;\n}\n\n// 静态方法（对应 Java 的 static native 方法）注意第二个参数类型是 jclass\nstatic jstring native_staticEcho(JNIEnv* env, jclass clazz, jstring js) {\n    const char* s = (*env)->GetStringUTFChars(env, js, NULL);\n    if (s == NULL) { // OOM or other error\n        return NULL;\n    }\n    // 这里可以处理字符串，演示直接返回一个新字符串\n    jstring ret = (*env)->NewStringUTF(env, s);\n    (*env)->ReleaseStringUTFChars(env, js, s);\n    return ret;\n}\n\n// -------------------- 方法表：Java 名称、签名、C 函数指针 --------------------\nstatic JNINativeMethod methods[] = {\n    // { \"Java 方法名\", \"JNI 签名\", (void*)本地函数指针 }\n    {\"sayHello\", \"()V\", (void*)native_sayHello},\n    {\"add\", \"(II)I\", (void*)native_add},\n    {\"staticEcho\", \"(Ljava/lang/String;)Ljava/lang/String;\", (void*)native_staticEcho}\n};\n\n// 辅助：计算方法表大小\nstatic const int methods_count = sizeof(methods) / sizeof(methods[0]);\n\n// -------------------- 注册函数（封装 RegisterNatives） --------------------\nstatic int register_native_methods(JNIEnv* env) {\n    // 注意：这里的类路径使用斜杠，不使用点号\n    const char* kClassPathName = \"com/example/MyClass\";\n    jclass clazz = (*env)->FindClass(env, kClassPathName);\n    if (clazz == NULL) {\n        // 如果 FindClass 失败，打印并清理异常（如果有）\n        if ((*env)->ExceptionCheck(env)) {\n            (*env)->ExceptionDescribe(env);\n            (*env)->ExceptionClear(env);\n        }\n        return JNI_FALSE;\n    }\n\n    // RegisterNatives 返回 < 0 表示失败\n    if ((*env)->RegisterNatives(env, clazz, methods, methods_count) < 0) {\n        if ((*env)->ExceptionCheck(env)) {\n            (*env)->ExceptionDescribe(env);\n            (*env)->ExceptionClear(env);\n        }\n        return JNI_FALSE;\n    }\n\n    // 如果你需要长期引用这个 jclass，应该创建全局引用：\n    // jclass globalClazz = (*env)->NewGlobalRef(env, clazz);\n    // 然后存储 globalClazz 供以后使用，并在卸载时 DeleteGlobalRef。\n    return JNI_TRUE;\n}\n\n// -------------------- JNI_OnLoad：库被 System.loadLibrary 时 JVM 调用 --------------------\nJNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved) {\n    JNIEnv* env = NULL;\n\n    // 获取 JNIEnv 指针 —— 注意线程安全与返回值检查\n    if ((*vm)->GetEnv(vm, (void**)&env, JNI_VERSION_1_6) != JNI_OK) {\n        return JNI_ERR; // 表示加载失败\n    }\n\n    // 注册 native 方法（通常在这里做，但 Android 情况见后文）\n    if (!register_native_methods(env)) {\n        return JNI_ERR; // 注册失败，返回错误使加载失败\n    }\n\n    // 返回所支持的 JNI 版本\n    return JNI_VERSION_1_6;\n}\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n\n```\n\n注意，这里的register_native_methods并不是必须要写的，它的作用只是让代码结构更清晰\n\n一个典型的辅助函数\n\n```C\nstatic int register_native_methods(JNIEnv* env, const char* className, JNINativeMethod* methods, int numMethods) {\n    jclass clazz = (*env)->FindClass(env, className);\n    if (clazz == NULL) {\n        return JNI_FALSE;\n    }\n    if ((*env)->RegisterNatives(env, clazz, methods, numMethods) < 0) {\n        return JNI_FALSE;\n    }\n    return JNI_TRUE;\n}\n\n```\n\n而Jni_Onload是必须的\n\n在Java层执行system.loadLibrary的时候被Jvm自动调用，当 native 库被加载时，完成初始化，比如注册 native 函数。\n\nJNI\\_OnLoad的标准写法\n\n```C\nJNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved)\n{\n    JNIEnv* env = NULL;\n\n    // 1. 获取 JNIEnv 指针\n    if ((*vm)->GetEnv(vm, (void**)&env, JNI_VERSION_1_6) != JNI_OK) {\n        return JNI_ERR;\n    }\n\n    // 2. 调用自己写的注册函数（可选）\n    if (!register_native_methods(env, \"com/example/MyClass\", methods, sizeof(methods) / sizeof(methods[0]))) {\n        return JNI_ERR;\n    }\n\n    // 3. 返回 JNI 版本号（必须）\n    return JNI_VERSION_1_6;\n}\n\n```\n\n在动态注册中，核心函数是\n\n```C\njint RegisterNatives(JNIEnv* env, jclass clazz, const JNINativeMethod* methods, jint nMethods);\n```\n\n注意，这个methods参数，是一个数组，类型为\n\n```C\ntypedef struct {\n    const char* name;       // Java 方法名\n    const char* signature;  // Java 方法签名（描述参数与返回值类型）\n    void* fnPtr;            // 对应的 C 函数指针\n} JNINativeMethod;\n```\n\n如果不传这个表，RegisterNatives()就不知道在注册什么东西\n\n所以也就是说，从逻辑上来看，方法表是一个必须的东西\n\n方法表的结构如下\n\n```C\nstatic JNINativeMethod methods[] = {\n    {\"sayHello\", \"()V\", (void*)native_sayHello},\n    {\"add\", \"(II)I\", (void*)native_add}\n};\n```\n\n\"sayHello\"这个字段表示函数名\n\n\"()V\"这个字段表示void\n\n(void*)native_sayHello字段表示函数地址\n\n第二个字段的常见签名方法如下\n\nJava 类型 -\\> JNI 签名\n\n- ​`void` -\\> `V`​\n- ​`boolean` -\\> `Z`​\n- ​`byte` -\\> `B`​\n- ​`char` -\\> `C`​\n- ​`short` -\\> `S`​\n- ​`int` -\\> `I`​\n- ​`long` -\\> `J`​\n- ​`float` -\\> `F`​\n- ​`double` -\\> `D`​\n- ​`Object` -\\> `Lfull/package/ClassName;` （包名用 `/`，例如 `Ljava/lang/String;`）\n- ​`int[]` -\\> `[I`、`String[]` -\\> `[Ljava/lang/String;`​\n\n举例：\n\n- ​`void foo()` -\\> `()V`​\n- ​`int sum(int a, int b)` -\\> `(II)I`​\n- ​`String process(String s, int[] arr)` -\\> `(Ljava/lang/String;[I)Ljava/lang/String;`​\n\n‍\n\n### 逆向\n\n同样可以看到注册了个native函数\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20251013213415.png)\n\n到了native层，可以发现大不同了\n\n首先可以看到JNI_Onload函数，看不到静态注册格式命名的函数名了\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20251013214105.png)\n\n那么应该怎样看动态注册了哪些函数呢\n\n还记得吗，在源码中，我们是写了一个“函数表”的\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20251013214246.png)\n\n在IDA中，如果没去符号表，是可以看到的\n\n我们点进去，就可以看到动态注册了哪些函数了\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20251013214313.png)\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20251013214347.png)\n\n‍\n","tags":["移动安全"],"categories":["逆向"]},{"title":"360加固保免费版分析","url":"/2025/07/25/360加固保免费版/","content":"\n分析360加固保免费版，学习逆向技术（此篇未完结）\n\n<!--more-->\n\n使用360加固保免费版加固，注意加固时要把签名校验给去除，因为加固之后的app是没有签名的，自己签名之后如果有签名校验，程序可能会闪退\n\n‍\n\n## Java层分析\n\n这是我自己写的一个app，可以看到没有加固时可以直接看到MainActivity\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709153602-4evta90.png)\n\n加固之后MainActivity字样没了，出现了StubAPP类和tianyu.util字样，可以知道这就是该加固的特征\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709153635-jfl8eqm.png)\n\nStubApp类里面使用a方法传递了一串字符串，跟进a方法，注意a有多个重载方法，需要查看具有一个字符串参数的重载方法\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709153810-asonqbd.png)\n\n发现就是对字符串进行一个解混淆，方式为异或16，这里可以用Cyberchef先解一下看看\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709153944-uz9a4kn.png)\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709154014-t5t5958.png)\n\n使用Frida hook看看这个方法做了些什么，直接在jadx里选择复制为frida片段\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709154239-eelvct9.png)\n\n```js\nfunction hook() {\n\n\n    let a = Java.use(\"com.tianyu.util.a\");\n    a[\"a\"].overload('java.lang.String').implementation = function (str) {\n        console.log(`a.a is called: str=${str}`);\n        let result = this[\"a\"](str);\n        console.log(`a.a result=${result}`);\n        return result;\n    };\n\n}\n\nfunction main() {\n\n    Java.perform(function () {\n        hook();\n    })\n}\n```\n\n可以看到就是加载了一些Android系统内部类或方法名\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709154306-w7jr6xk.png)\n\n继续观察StubApp类，看见下面会根据设备的架构来加载不同的so文件\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709155119-s00uw2u.png)\n\n再与正常未加固的apk对比一下，发现加固之后的apk多了一个assets文件夹，里面存着一些so文件\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709155941-sxtt2uw.png)\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709155958-xxqst5f.png)\n\n不难分析出，该加固是在Native层来释放dex文件\n\n‍\n\n## Native层分析\n\n分析so文件，发现导入导出表被抹除得一干二净\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709160226-czuhur7.png)\n\n如果没有导入导出表的话，elf文件应该是使用了自定义的动态链接器来进行链接的，所以，只要再elf文件被装载进内存之后将它dump下来，应该就能恢复符号表了\n\n在Linux系统中，dlopen函数用于动态链接库加载函数，它存在于`libdl.so`库中\n\n```C\n// 1. 加载库\nvoid* libHandle = dlopen(\"/data/data/pkg/libnative.so\", RTLD_NOW);\nif (!libHandle) {\n    printf(\"Error: %s\\n\", dlerror());\n    return;\n}\n\n// 2. 获取函数指针\ntypedef int (*NativeFunc)(int);\nNativeFunc func = (NativeFunc)dlsym(libHandle, \"native_add\");\nif (!func) {\n    printf(\"Error: %s\\n\", dlerror());\n    dlclose(libHandle);\n    return;\n}\n\n// 3. 调用函数\nint result = func(42);\n\n// 4. 卸载库\ndlclose(libHandle);\n```\n\n在安卓7.0之后，则需要hook的是android_dlopen_ext函数\n\nfrida hook一下看看它加载了哪些函数\n\nandroid_dlopen_ext() 的格式为`android_dlopen_ext(\"/data/data/pkg/libsecret.so\", RTLD_NOW, NULL);`，所以我们需要获取第一个参数的值来得到它链接了哪些so文件\n\n```C\nfunction hook() {\n\n    Interceptor.attach(Module.findExportByName(\"libdl.so\", \"android_dlopen_ext\"), {\n        onEnter: function (args) {\n            // console.log('Entering ' + functionName);\n            // Modify or log arguments if needed\n            console.log(\"load -> \", args[0].readCString());\n        },\n        onLeave: function (retval) {\n            // console.log('Leaving ' + functionName);\n            // Modify or log return value if needed\n        }\n    });\n}\n\nfunction main() {\n\n    Java.perform(function () {\n        hook();\n    })\n}\n\nsetImmediate(main);\n```\n\n正如所料，它链接了这个so文件\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709163334-dxuld2c.png)\n\n接下来在它将该so文件装载到内存之后dump下来，就可以得到带有导入导出表的so文件了\n\n（dump脚本来自SWDD）\n\n```js\nfunction dump_so() {\n    var soName = \"libjiagu_64.so\";\n    var libSo = Process.getModuleByName(soName);\n    var save_path = \"/data/data/com.example.nativetest/\" + libSo.name + \"_Dump\";\n    console.log(\"[Base]->\", libSo.base);\n    console.log(\"[Size]->\", ptr(libSo.size));\n    var handle = new File(save_path, \"wb\");\n    Memory.protect(ptr(libSo.base), libSo.size, 'rwx');\n    var Buffer = libSo.base.readByteArray(libSo.size);\n    handle.write(Buffer);\n    handle.flush();\n    handle.close();\n    console.log(\"[DumpPath->]\", save_path);\n\n}\n\nsetImmediate(dump_so);\n```\n\n注意，要在app运行之后再把脚本附加上去，否则如果还没来得及链接就dump的话，frida会直接报错\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709163731-zkjq895.png)\n\n所以这里使用命令\n\n```js\nfrida -U 'NativeTest' -l dump_so.js\n```\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709163808-0cfeau3.png)\n\n成功dump，并且得到了文件的基地址和大小\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709163918-56u3gz5.png)\n\n成功恢复\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709164129-v3p5sc3.png)\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709164143-2l9gqse.png)\n\n‍\n\n## 壳文件分析\n\n这里有一个知识点\n\n> ### **加固壳的典型行为模式**\n>\n> 加固壳的核心任务是 **保护原始代码**，其常见流程包括：\n>\n> 1. **解密资源**：\n>\n>     - 原始 APK/Dex/So 文件被加密，隐藏在 `assets`、`lib/` 或自定义目录中。\n>     - 运行时，壳代码需要先 **读取这些加密文件**（通过 `open` + `read`）。\n> 2. **动态加载**：\n>\n>     - 解密后的文件（如 Dex、So）会通过 `dlopen`、`mmap` 或 `DexClassLoader` 加载到内存。\n> 3. **内存执行**：\n>\n>     - 解密后的代码在内存中执行，避免留下完整的磁盘文件。\n>\n> **关键点**：  \n> ➜ **加固壳必须读取加密文件** → 必然调用 `open` 函数 → **Hook** **​`open`​** **可以捕获文件访问路径**。\n\n思路就是 hook open函数来看看它有没有读取什么东西\n\n```js\nfunction hook() {\n\n    var openPtr = Module.findExportByName(null, \"open\");\n    // var openAdrr = new NativePointer(openPtr);\n    const open = new NativeFunction(openPtr, 'int', ['pointer', 'int']);\n\n    Interceptor.replace(openPtr, new NativeCallback(function (fileNamePtr, flag) {\n        \n        var fileName = fileNamePtr.readCString();\n        console.log(\"[open : ]\", fileName);\n\n        return open(fileNamePtr, flag);\n    } , 'int', ['pointer', 'int']))\n\n\n}\n\nfunction main() {\n\n    Java.perform(function () {\n        hook();\n    })\n}\n\n// setTimeout(main, 1000);\nsetImmediate(main);\n```\n\n注意这里一定要new一个NativeCallback\n\n在 Frida 中，`NativeCallback` 的作用是 **创建一个符合原生代码调用约定的 JavaScript 回调函数**，用于替换或拦截原生函数（如 `open`）\n\n原生代码（如 C 的 `open` 函数）有严格的 **参数传递规则**（如寄存器/栈传参、类型转换），而 JavaScript 是弱类型语言，无法直接匹配\n\n不然的话会出现如下报错\n\n`fileNamePtr` 可能未被正确识别为 `pointer` 类型\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709215005-d6hgc81.png)\n\n可以看到打开了如下文件\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709215238-5ec1xgp.png)\n\n发现个很可疑的点，它频繁访问了 /proc/self/maps\n\n> ###   **​`/proc/self/maps`​** **的作用**\n>\n> - **功能**：该文件实时显示当前进程的内存映射布局，包括：\n>\n>   - 加载的模块（`.so`/`.dex`）基地址和大小\n>   - 内存权限（可读/可写/可执行）\n>   - 文件来源路径\n> - **典型访问场景**：\n>\n>   - **加固壳**：检测内存是否被篡改（反调试）。\n>   - **动态加载库**：定位空闲内存区域加载新代码。\n>   - **内存扫描**：查找敏感数据或函数地址。\n\n这里反复读取maps猜测是为了混淆视听，当加载dex时，maps上的内存映射会发生变化，留下记录，比如 /data/app/xxx/base.dex，这时候壳文件就通过反复读取maps来隐藏打开dex的操作，掩盖真正的 Dex 加载时机\n\n此时，如果我们自定义一个fakeMaps，将壳文件对maps的操作重定向到我们的fakeMaps上，就可以很方便地观察壳文件加载dex的操作了，同时也能避免壳的反检测机制（如果有的话）\n\n```js\nfunction hook() {\n\n    var openPtr = Module.findExportByName(null, \"open\");\n    // var openAdrr = new NativePointer(openPtr);\n    const open = new NativeFunction(openPtr, 'int', ['pointer', 'int']);\n\n    var fakeMaps = \"/data/data/com.example.nativetest/maps\"\n\n    Interceptor.replace(openPtr, new NativeCallback(function (fileNamePtr, flag) {\n\n        var fileName = fileNamePtr.readCString();\n        console.log(\"[open : ]\", fileName);\n\n        var FD = open(fileNamePtr, flag); //调用原始open函数，记录原始open函数的文件描述符\n\n        if (fileName.indexOf(\"maps\") >= 0) {  //如果文件名包含maps，将其重定向到fakeMaps上\n            \n            console.log(\"sucess find maps\");\n\n            var fakeMapsAddr = Memory.allocUtf8String(fakeMaps);\n            return open(fakeMapsAddr, flag); // 打开伪造的maps文件，并返回其文件描述符（FD），而非真实的maps\n            \n        }\n\n        if (fileName.indexOf(\"dex\" != -1)) {\n            console.warn(\"open dex :\", fileName);\n        }\n\n        return FD; //返回原始FD使app正常运行\n        // return open(fileNamePtr, flag);\n    }, 'int', ['pointer', 'int']))\n\n\n}\n\nfunction main() {\n\n    Java.perform(function () {\n        hook();\n    })\n}\n\n// setTimeout(main, 1000);\nsetImmediate(main);\n\n```\n\n可以发现确实是通过open去打开了dex文件，而且通过反复读取了maps来隐藏操作，验证了我们之前的猜想\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250715203358.png)\n\n使用来查看dex的内存地址\n\n```js\nconsole.warn('dex called from:\\n' + Thread.backtrace(this.context, Backtracer.FUZZY).map(DebugSymbol.fromAddress).join('\\n') + '\\n');\n```\n\n```js\nfunction hook() {\n\n    var openPtr = Module.findExportByName(null, \"open\");\n    // var openAdrr = new NativePointer(openPtr);\n    const open = new NativeFunction(openPtr, 'int', ['pointer', 'int']);\n    var fakeMaps = \"/data/data/com.example.nativetest/maps\";\n\n    Interceptor.replace(openPtr, new NativeCallback(function (fileNamePtr, flag) {\n\n        var fileName = fileNamePtr.readCString();\n        console.log(\"[open : ]\", fileName);\n        var FD = open(fileNamePtr, flag); //调用原始open函数，记录原始open函数的文件描述符\n\n        if (fileName.indexOf(\"maps\") >= 0) {  //如果文件名包含maps，将其重定向到fakeMaps上\n            \n            console.log(\"sucess find maps\");\n            var fakeMapsAddr = Memory.allocUtf8String(fakeMaps);\n            return open(fakeMapsAddr, flag); // 打开伪造的maps文件，并返回其文件描述符（FD），而非真实的maps\n            \n        }\n\n        if (fileName.indexOf(\"dex\") != -1) {\n            console.warn(\"open dex :\", fileName);\n            console.warn('dex called from:\\n' + Thread.backtrace(this.context, Backtracer.FUZZY).map(DebugSymbol.fromAddress).join('\\n') + '\\n');\n            \n        }\n\n        return FD; //返回原始FD使app正常运行\n        // return open(fileNamePtr, flag);\n    }, 'int', ['pointer', 'int']))\n\n\n}\n\nfunction main() {\n\n    Java.perform(function () {\n        hook();\n    })\n}\n\n// setTimeout(main, 1000);+\nsetImmediate(main);\n```\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250715205613.png)\n\n可以发现打开dex的地址基本一模一样，在IDA中查看这个地址\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250715205949.png)\n\n嘶，啥也没有，这不对吧\n\n查阅多方资料，发现我漏了一步，在先前dump so文件的时候，so文件可能会有损坏，所以先需要修复一下so文件\n\n使用soFixer\n\n[soFixer](https://github.com/F8LEFT/SoFixer)   0x0x7fff56d99000是之前dump so文件的时候输出的基地址\n\n```js\n.\\SoFixer-Windows-64.exe -s .\\libjiagu_64.so_Dump -o .\\libjiagu_64.so_Fix -m 0x7fff56d99000 -d\n```\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250715210744.png)\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250715210721.png)\n\n使用sofix之后IDA将其识别成了ARM架构，但是我原本的文件是x86_64架构，这里要重新选择一下\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250715211520.png)\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250715211720.png)\n\n这下就没问题了\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250715212218.png)\n\n但是这段数据全是未定义的，这个时候就手足无措了\n\n一通乱翻，发现了这样一个函数\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250715220229.png)\n\n```C\nchar __fastcall __arm_a_2(char *a1, unsigned __int64 a2, char *a3, int *a4, unsigned int a5)\n{\n  unsigned __int64 v5; // rax\n  __int64 *v6; // rsi\n  __int64 v7; // rbx\n  __int64 *v8; // rdi\n  __int64 v9; // rax\n  _QWORD *v10; // rbx\n  char v12[8]; // [rsp+90h] [rbp-168h] BYREF\n  unsigned __int64 v13; // [rsp+98h] [rbp-160h]\n  __int64 v14; // [rsp+A0h] [rbp-158h]\n  __int64 v15[7]; // [rsp+B0h] [rbp-148h] BYREF\n  _QWORD v16[2]; // [rsp+E8h] [rbp-110h] BYREF\n  __int128 v17; // [rsp+F8h] [rbp-100h]\n  __int128 v18[8]; // [rsp+108h] [rbp-F0h] BYREF\n  __int128 v19; // [rsp+188h] [rbp-70h]\n  __int128 v20; // [rsp+198h] [rbp-60h]\n  __int128 v21[2]; // [rsp+1A8h] [rbp-50h] BYREF\n  int *v22; // [rsp+1D0h] [rbp-28h]\n  unsigned __int64 v23; // [rsp+1D8h] [rbp-20h]\n  unsigned __int64 v24; // [rsp+1E8h] [rbp-10h]\n\n  v24 = __readfsqword(0x28u);\n  v23 = a5;\n  v22 = a4;\n  sub_2DA0();\n  v5 = __readfsqword(0x28u);\n  if ( v5 != v24 )\n  {\n    sub_2D40(qword_1C928, 0x190LL);\n    v23 = a1;\n    v22 = __readfsqword(0x28u);\n    memset(v21, 0, sizeof(v21));\n    v20 = 0LL;\n    v19 = 0LL;\n    memset(v18, 0, sizeof(v18));\n    v17 = 0LL;\n    sub_2D20(v18 + 4, \"*.so\", 0x80LL, 0xBCLL, 5LL);\n    v16[0] = &qword_234D0;\n    v16[1] = 0xAC3FDLL;\n    LODWORD(v18[0]) = 1;\n    *&v20 = off_233B8;\n    *(&v19 + 1) = &qword_CFD40;\n    DWORD2(v21[1]) = 1;\n    *(&v20 + 1) = 0x400000002LL;\n    LODWORD(v21[0]) = 5;\n    *(v21 + 8) = 0LL;\n    sub_7330(v15);\n    v15[0] = qword_22CA8 + 16;\n    v6 = &qword_CF8D0;\n    if ( sub_7770(v15, &qword_CF8D0, 1062LL) )\n    {\n      v6 = v15;\n      v7 = sub_5C10(v16, v15);\n      if ( *(&v21[0] + 1) )\n        (sub_2EE0)();\n    }\n    else\n    {\n      v7 = 0LL;\n    }\n    v8 = v15;\n    sub_7580(v15);\n    if ( __readfsqword(0x28u) == v22 )\n    {\n      LOBYTE(v5) = v7;\n    }\n    else\n    {\n      sub_2D40(v15, v6);\n      v14 = v7;\n      v13 = __readfsqword(0x28u);\n      if ( v15 )\n      {\n        strcpy(v12, \"makekey\");\n        v6 = v12;\n        v9 = sub_5D40(v15, v12);\n        if ( v9 )\n        {\n          v10 = v9;\n          v8 = (v9 & 0xFFFFFFFFFFFFF000LL);\n          v6 = (\"pthread_create\" + 3);\n          sub_2E50(v9 & 0xFFFFFFFFFFFFF000LL, 4096LL, 3LL);\n          *v10 = qword_22CC0;\n        }\n      }\n      v5 = __readfsqword(0x28u);\n      if ( v5 != v13 )\n      {\n        sub_2D40(v8, v6);\n        LOBYTE(v5) = 1;\n      }\n    }\n  }\n  return v5;\n}\n```\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250715220849.png)\n\n查看sub_50E0\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250715220917.png)\n\n发现了一些用于加载动态链接相关的字符串，结合之前创建线程，这个时候就猜测，应该已经在加载另外的so了\n\n‍\n\n安卓系统中，完成linker之后，dlopen去加载这个so，我们之前hook的是`android_dlopen_ext`，这里再去hook一下dlopen看看它加载了哪些so文件\n\n```js\nfunction hook() {\n\n    Interceptor.attach(Module.findExportByName(\"libdl.so\", \"android_dlopen_ext\"), {\n        onEnter: function (args) {\n            // console.log('Entering ' + functionName);\n            // Modify or log arguments if needed\n            console.log(\"load -> \", args[0].readCString());\n        },\n        onLeave: function (retval) {\n            // console.log('Leaving ' + functionName);\n            // Modify or log return value if needed\n        }\n    });\n\n}\n\nfunction hook2() {\n    \n    Interceptor.attach(Module.findExportByName(\"libdl.so\", \"dlopen\"), {\n        onEnter: function (args) {\n            // console.log('Entering ' + functionName);\n            // Modify or log arguments if needed\n            console.warn(\"dlopen load -> \", args[0].readCString());\n        },\n        onLeave: function (retval) {\n            // console.log('Leaving ' + functionName);\n            // Modify or log return value if needed\n        }\n    });\n}\n\nfunction main() {\n\n    Java.perform(function () {\n        hook();\n        hook2();\n    })\n}\n\n// setTimeout(main, 1000);\nsetImmediate(main);\n```\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716105833.png)\n\n看到这里，基本上可以说明就是自定义linker加固so文件了\n\n‍\n\n查阅资料发现，自定义linker加固so的流程是，自定义文件格式加密so，然后壳代码实现将加密的so文件加载，链接重定位并修正soinfo（三部曲）\n\n简单来说就是将elf文件的.text等数据段进行加密，然后在link的时候补充soinfo\n\n> `soinfo` 是 **Android linker** 内部维护的数据结构，用于 **管理已加载的共享库（.so）** 。每个被 `dlopen` 或程序依赖的 `.so` 都会有一个对应的 `soinfo` 结构，存储：\n>\n> - **库的基地址（加载地址）**\n> - **符号表、重定位表、依赖关系**\n> - **动态段（**​ **​`.dynamic`​**​ **）解析后的信息**\n> - **命名空间（用于库隔离）**\n> - ### **​`soinfo`​** **的生命周期**\n>\n>   1. **加载阶段**：`dlopen` → `linker` 解析 ELF → 创建 `soinfo` 并填充信息。\n>   2. **链接阶段**：`linker` 根据 `.dynamic` 段解析依赖、符号、重定位。\n>   3. **运行时**：`dlsym` 通过 `soinfo` 查找符号地址。\n>   4. **卸载阶段**：`dlclose` 释放 `soinfo`。\n\n由于之前的so在执行的时候link了另外的so，所以将其放入010editor里查找elf头\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716112140.png)\n\n找到了elf头，并且可以看到program header已经被加密了\n\n写一个脚本，将0xd0000之后的内容提取出来\n\n提取出来的so文件ida是打不开的，因为program header已经被加密了\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716113145.png)\n\n此时就需要找到这个so是在哪里被解密的\n\n用oacia大佬的项目来分析一下程序执行流\n\n[https://github.com/oacia/stalker_trace_so](https://github.com/oacia/stalker_trace_so)\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716114648.png)\n\n```js\n[Android Emulator 5554::com.example.nativetest ]-> start Stalker!\nStalker end!\ncall1:JNI_OnLoad\ncall2:sub_C840\ncall3:ffi_call\ncall4:sub_C450\ncall5:sub_7330\ncall6:sub_7770\ncall7:sub_7370\ncall8:_ZN9__arm_c_19__arm_c_0Ev\ncall9:sub_77B0\ncall10:sub_71F0\ncall11:sub_C560\ncall12:sub_7240\ncall13:sub_42C0\ncall14:sub_6310\ncall15:sub_6A30\ncall16:sub_6760\ncall17:sub_4B40\ncall18:sub_4F70\ncall19:sub_50E0\ncall20:sub_3B20\ncall21:sub_7000\ncall22:sub_6350\ncall23:sub_7580\ncall24:sub_10E1D0\ncall25:sub_1BC3C0\ncall26:sub_10B270\ncall27:sub_1465C0\ncall28:sub_14AC90\ncall29:sub_10A5C0\ncall30:sub_1BDD20\ncall31:sub_14B3E0\ncall32:sub_14D100\ncall33:sub_1BDD50\ncall34:sub_1A9BD0\ncall35:sub_1459B0\ncall36:sub_1BD700\ncall37:sub_1BD790\ncall38:sub_10ED90\ncall39:sub_1120F0\ncall40:sub_10CC10\ncall41:sub_106F90\ncall42:sub_1BB530\ncall43:sub_1BB620\ncall44:sub_1BC4E0\ncall45:sub_1BB980\ncall46:sub_1BBC00\ncall47:sub_1BBE10\ncall48:sub_1BC1D0\ncall49:sub_1BC4B0\ncall55:sub_1BDF10\ncall56:sub_116720\ncall57:sub_1BDD00\ncall58:sub_1AD9E0\ncall59:sub_1ADB60\ncall60:sub_1C49A0\ncall61:sub_1CAD30\ncall62:sub_1C8EC0\ncall63:sub_16FA70\n```\n\n再看一下fix之后的文件的控制流\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716200634.png)\n\n```js\n[Android Emulator 5554::com.example.nativetest ]-> start Stalker!\ncall1:JNI_OnLoad\ncall2:sub_C840\ncall3:ffi_call\ncall4:sub_C450\ncall5:sub_7330\ncall6:sub_7770\ncall7:sub_7370\ncall8:_ZN9__arm_c_19__arm_c_0Ev\ncall9:sub_77B0\ncall10:sub_71F0\ncall11:sub_C560\ncall12:sub_7240\ncall13:sub_42C0\ncall14:sub_6310\ncall15:sub_6A30\ncall16:sub_6760\ncall17:sub_4B40\ncall18:sub_4F70\ncall19:sub_50E0\ncall20:sub_3B20\ncall21:sub_7000\ncall22:sub_6350\ncall23:sub_7580\ncall24:sub_10E1D0\ncall25:sub_1BC3C0\ncall26:sub_10B270\ncall27:sub_1465C0\ncall28:sub_14AC90\ncall29:sub_10A5C0\ncall30:sub_1BDD20\ncall31:sub_14B3E0\ncall32:sub_14D100\ncall33:sub_1BDD50\ncall34:sub_1A9BD0\ncall35:sub_1459B0\ncall36:sub_1BD700\ncall37:sub_1BD790\ncall38:sub_10ED90\ncall39:sub_1120F0\ncall40:sub_10CC10\ncall41:sub_106F90\ncall42:sub_1BB530\ncall43:sub_1BB620\ncall44:sub_1BC4E0\ncall45:sub_1BB980\ncall46:sub_1BBC00\ncall47:sub_1BBE10\ncall48:sub_1BC1D0\ncall49:sub_1BC4B0\ncall50:sub_14B000\ncall51:sub_14D310\ncall52:_Z9__arm_a_2PcmS_Rii\ncall53:sub_14ACC0\ncall54:sub_10C5F0\ncall55:sub_1BDF10\ncall56:sub_116720\ncall57:sub_1BDD00\ncall58:sub_1AD9E0\ncall59:sub_1ADB60\ncall60:sub_1C49A0\ncall61:sub_1CAD30\ncall62:sub_1C8EC0\ncall63:sub_16FA70\n```\n\n‍\n\n‍\n\n知道了控制流之后，虽然是自定义linker加固so，但是最后肯定还是需要dlopen去加载so的，在IDA里交叉引用一下dlopen，看看在哪里被调用了\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716115942.png)\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716120042.png)\n\n只有一处调用，全是switch case结构\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716120058.png)\n\n查看Android源码linker的预链接部分，同样也是大量的switch case结构\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716160821.png)\n\n此时就可以在IDA中导入soinfo结构体了（结构体代码来自SWDD）\n\n```js\n//IMPORTANT\n//ELF64 启用该宏\n#define __LP64__  1\n//ELF32 启用该宏\n//#define __work_around_b_24465209__  1\n \n/*\n//https://android.googlesource.com/platform/bionic/+/master/linker/Android.bp\n架构为 32 位 定义__work_around_b_24465209__宏\narch: {\n        arm: {cflags: [\"-D__work_around_b_24465209__\"],},\n        x86: {cflags: [\"-D__work_around_b_24465209__\"],},\n    }\n*/\n \n//android-platform\\bionic\\libc\\include\\link.h\n#if defined(__LP64__)\n#define ElfW(type) Elf64_ ## type\n#else\n#define ElfW(type) Elf32_ ## type\n#endif\n \n//android-platform\\bionic\\linker\\linker_common_types.h\n// Android uses RELA for LP64.\n#if defined(__LP64__)\n#define USE_RELA 1\n#endif\n \n//android-platform\\bionic\\libc\\kernel\\uapi\\asm-generic\\int-ll64.h\n//__signed__-->signed\ntypedef signed char __s8;\ntypedef unsigned char __u8;\ntypedef signed short __s16;\ntypedef unsigned short __u16;\ntypedef signed int __s32;\ntypedef unsigned int __u32;\ntypedef signed long long __s64;\ntypedef unsigned long long __u64;\n \n//A12-src\\msm-google\\include\\uapi\\linux\\elf.h\n/* 32-bit ELF base types. */\ntypedef __u32   Elf32_Addr;\ntypedef __u16   Elf32_Half;\ntypedef __u32   Elf32_Off;\ntypedef __s32   Elf32_Sword;\ntypedef __u32   Elf32_Word;\n \n/* 64-bit ELF base types. */\ntypedef __u64   Elf64_Addr;\ntypedef __u16   Elf64_Half;\ntypedef __s16   Elf64_SHalf;\ntypedef __u64   Elf64_Off;\ntypedef __s32   Elf64_Sword;\ntypedef __u32   Elf64_Word;\ntypedef __u64   Elf64_Xword;\ntypedef __s64   Elf64_Sxword;\n \ntypedef struct dynamic{\n  Elf32_Sword d_tag;\n  union{\n    Elf32_Sword d_val;\n    Elf32_Addr  d_ptr;\n  } d_un;\n} Elf32_Dyn;\n \ntypedef struct {\n  Elf64_Sxword d_tag;       /* entry tag value */\n  union {\n    Elf64_Xword d_val;\n    Elf64_Addr d_ptr;\n  } d_un;\n} Elf64_Dyn;\n \ntypedef struct elf32_rel {\n  Elf32_Addr    r_offset;\n  Elf32_Word    r_info;\n} Elf32_Rel;\n \ntypedef struct elf64_rel {\n  Elf64_Addr r_offset;  /* Location at which to apply the action */\n  Elf64_Xword r_info;   /* index and type of relocation */\n} Elf64_Rel;\n \ntypedef struct elf32_rela{\n  Elf32_Addr    r_offset;\n  Elf32_Word    r_info;\n  Elf32_Sword   r_addend;\n} Elf32_Rela;\n \ntypedef struct elf64_rela {\n  Elf64_Addr r_offset;  /* Location at which to apply the action */\n  Elf64_Xword r_info;   /* index and type of relocation */\n  Elf64_Sxword r_addend;    /* Constant addend used to compute value */\n} Elf64_Rela;\n \ntypedef struct elf32_sym{\n  Elf32_Word    st_name;\n  Elf32_Addr    st_value;\n  Elf32_Word    st_size;\n  unsigned char st_info;\n  unsigned char st_other;\n  Elf32_Half    st_shndx;\n} Elf32_Sym;\n \ntypedef struct elf64_sym {\n  Elf64_Word st_name;       /* Symbol name, index in string tbl */\n  unsigned char st_info;    /* Type and binding attributes */\n  unsigned char st_other;   /* No defined meaning, 0 */\n  Elf64_Half st_shndx;      /* Associated section index */\n  Elf64_Addr st_value;      /* Value of the symbol */\n  Elf64_Xword st_size;      /* Associated symbol size */\n} Elf64_Sym;\n \n#define EI_NIDENT   16\n \ntypedef struct elf32_hdr{\n  unsigned char e_ident[EI_NIDENT];\n  Elf32_Half    e_type;\n  Elf32_Half    e_machine;\n  Elf32_Word    e_version;\n  Elf32_Addr    e_entry;  /* Entry point */\n  Elf32_Off e_phoff;\n  Elf32_Off e_shoff;\n  Elf32_Word    e_flags;\n  Elf32_Half    e_ehsize;\n  Elf32_Half    e_phentsize;\n  Elf32_Half    e_phnum;\n  Elf32_Half    e_shentsize;\n  Elf32_Half    e_shnum;\n  Elf32_Half    e_shstrndx;\n} Elf32_Ehdr;\n \ntypedef struct elf64_hdr {\n  unsigned char e_ident[EI_NIDENT]; /* ELF \"magic number\" */\n  Elf64_Half e_type;\n  Elf64_Half e_machine;\n  Elf64_Word e_version;\n  Elf64_Addr e_entry;       /* Entry point virtual address */\n  Elf64_Off e_phoff;        /* Program header table file offset */\n  Elf64_Off e_shoff;        /* Section header table file offset */\n  Elf64_Word e_flags;\n  Elf64_Half e_ehsize;\n  Elf64_Half e_phentsize;\n  Elf64_Half e_phnum;\n  Elf64_Half e_shentsize;\n  Elf64_Half e_shnum;\n  Elf64_Half e_shstrndx;\n} Elf64_Ehdr;\n \n/* These constants define the permissions on sections in the program\n   header, p_flags. */\n#define PF_R        0x4\n#define PF_W        0x2\n#define PF_X        0x1\n \ntypedef struct elf32_phdr{\n  Elf32_Word    p_type;\n  Elf32_Off p_offset;\n  Elf32_Addr    p_vaddr;\n  Elf32_Addr    p_paddr;\n  Elf32_Word    p_filesz;\n  Elf32_Word    p_memsz;\n  Elf32_Word    p_flags;\n  Elf32_Word    p_align;\n} Elf32_Phdr;\n \ntypedef struct elf64_phdr {\n  Elf64_Word p_type;\n  Elf64_Word p_flags;\n  Elf64_Off p_offset;       /* Segment file offset */\n  Elf64_Addr p_vaddr;       /* Segment virtual address */\n  Elf64_Addr p_paddr;       /* Segment physical address */\n  Elf64_Xword p_filesz;     /* Segment size in file */\n  Elf64_Xword p_memsz;      /* Segment size in memory */\n  Elf64_Xword p_align;      /* Segment alignment, file & memory */\n} Elf64_Phdr;\n \ntypedef struct elf32_shdr {\n  Elf32_Word    sh_name;\n  Elf32_Word    sh_type;\n  Elf32_Word    sh_flags;\n  Elf32_Addr    sh_addr;\n  Elf32_Off sh_offset;\n  Elf32_Word    sh_size;\n  Elf32_Word    sh_link;\n  Elf32_Word    sh_info;\n  Elf32_Word    sh_addralign;\n  Elf32_Word    sh_entsize;\n} Elf32_Shdr;\n \ntypedef struct elf64_shdr {\n  Elf64_Word sh_name;       /* Section name, index in string tbl */\n  Elf64_Word sh_type;       /* Type of section */\n  Elf64_Xword sh_flags;     /* Miscellaneous section attributes */\n  Elf64_Addr sh_addr;       /* Section virtual addr at execution */\n  Elf64_Off sh_offset;      /* Section file offset */\n  Elf64_Xword sh_size;      /* Size of section in bytes */\n  Elf64_Word sh_link;       /* Index of another section */\n  Elf64_Word sh_info;       /* Additional section information */\n  Elf64_Xword sh_addralign; /* Section alignment */\n  Elf64_Xword sh_entsize;   /* Entry size if section holds table */\n} Elf64_Shdr;\n \n//android-platform\\bionic\\linker\\linker_soinfo.h\ntypedef void (*linker_dtor_function_t)();\ntypedef void (*linker_ctor_function_t)(int, char**, char**);\n \n#if defined(__work_around_b_24465209__)\n#define SOINFO_NAME_LEN 128\n#endif\n \nstruct soinfo {\n#if defined(__work_around_b_24465209__)\n  char old_name_[SOINFO_NAME_LEN];\n#endif\n  const ElfW(Phdr)* phdr;\n  size_t phnum;\n#if defined(__work_around_b_24465209__)\n  ElfW(Addr) unused0; // DO NOT USE, maintained for compatibility.\n#endif\n  ElfW(Addr) base;\n  size_t size;\n \n#if defined(__work_around_b_24465209__)\n  uint32_t unused1;  // DO NOT USE, maintained for compatibility.\n#endif\n \n  ElfW(Dyn)* dynamic;\n \n#if defined(__work_around_b_24465209__)\n  uint32_t unused2; // DO NOT USE, maintained for compatibility\n  uint32_t unused3; // DO NOT USE, maintained for compatibility\n#endif\n \n  soinfo* next;\n  uint32_t flags_;\n \n  const char* strtab_;\n  ElfW(Sym)* symtab_;\n \n  size_t nbucket_;\n  size_t nchain_;\n  uint32_t* bucket_;\n  uint32_t* chain_;\n \n#if !defined(__LP64__)\n  ElfW(Addr)** unused4; // DO NOT USE, maintained for compatibility\n#endif\n \n#if defined(USE_RELA)\n  ElfW(Rela)* plt_rela_;\n  size_t plt_rela_count_;\n \n  ElfW(Rela)* rela_;\n  size_t rela_count_;\n#else\n  ElfW(Rel)* plt_rel_;\n  size_t plt_rel_count_;\n \n  ElfW(Rel)* rel_;\n  size_t rel_count_;\n#endif\n \n  linker_ctor_function_t* preinit_array_;\n  size_t preinit_array_count_;\n \n  linker_ctor_function_t* init_array_;\n  size_t init_array_count_;\n  linker_dtor_function_t* fini_array_;\n  size_t fini_array_count_;\n \n  linker_ctor_function_t init_func_;\n  linker_dtor_function_t fini_func_;\n \n/*\n#if defined (__arm__)\n  // ARM EABI section used for stack unwinding.\n  uint32_t* ARM_exidx;\n  size_t ARM_exidx_count;\n#endif\n  size_t ref_count_;\n// 怎么找不 link_map 这个类型的声明...\n  link_map link_map_head;\n \n  bool constructors_called;\n \n  // When you read a virtual address from the ELF file, add this\n  //value to get the corresponding address in the process' address space.\n  ElfW (Addr) load_bias;\n \n#if !defined (__LP64__)\n  bool has_text_relocations;\n#endif\n  bool has_DT_SYMBOLIC;\n*/\n};\n```\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716161049.png)\n\n按Y将该函数类型改成so\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716161551.png)\n\n好看多了，但看着还是有点奇怪，可能这个soinfo被魔改过了\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716161625.png)\n\n交叉引用一下，来到上一个函数，有这样一个函数，我们点进去看看\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716161856.png)\n\n最终来到这个地方\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716162052.png)\n\n有一个很可疑的点是v5往上加了0x38\n\n![image](assets/image-20250716162637-7u4zl4e.png)\n\n在ELF文件中，32 位 ELF 文件程序头大小是 0x20（32 字节），64 位 ELF 文件程序头大小是 0x38（56 字节）\n\n这里正好就是0x38，所以这里可能就在加载程序头了。\n\n既然要加载程序头，那么在加载之前肯定需要解密，往上引用一下，最后又来到这里，有点眼熟\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716163100.png)\n\n还记得之前拿到的执行流么，从7000，即加载程序头的函数开始，往上找一找\n\n在50E0的位置发现这里加载了一些东西\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716201757.png)\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716201838.png)\n\n继续往上翻，在7240的位置填入了一个地址进去\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716210205.png)\n\n去那个地址看一眼，AUV，这不rc4么\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716210241.png)\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716210231.png)\n\n上面那个则是初始化算法\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716210313.png)\n\n直接hook出sbox\n\n‍\n","tags":["移动安全"],"categories":["逆向"]},{"title":"报任安书","url":"/2024/07/26/报任安书/","content":"\n然此可为智者道，难为俗人言也\n\n<!--more-->\n\n# 报任安书（节选）\n\n## 【两汉】司马迁\n\n古者富贵而名摩灭，不可胜记，唯倜傥非常之人称焉。盖文王拘而演《周易》；仲尼厄而作《春秋》；屈原放逐，乃赋《离骚》；左丘失明，厥有《国语》；孙子膑脚，《兵法》修列；不韦迁蜀，世传《吕览》；韩非囚秦，《说难》《孤愤》；《诗》三百篇，大底圣贤发愤之所为作也。此人皆意有所郁结，不得通其道，故述往事、思来者。乃如左丘无目，孙子断足，终不可用，退而论书策，以舒其愤，思垂空文以自见。\n\n　　仆窃不逊，近自托于无能之辞，网罗天下放失旧闻，略考其行事，综其终始，稽其成败兴坏之纪，上计轩辕，下至于兹，为十表，本纪十二，书八章，世家三十，列传七十，凡百三十篇。亦欲以究天人之际，通古今之变，成一家之言。草创未就，会遭此祸，惜其不成，是以就极刑而无愠色。仆诚以著此书，藏之名山，传之其人，通邑大都，则仆偿前辱之责，虽万被戮，岂有悔哉！然此可为智者道，难为俗人言也！\n","tags":["古代散文"],"categories":["古文"]},{"title":"[DASCTF2024夏季挑战赛]StrangePrograme","url":"/2024/07/25/DASCTF2024夏季挑战赛-StrangePrograme/","content":"眼前所见，亦非真实\n<!--more-->\n你看到的我并不是真正的我，你看到的memcmp不是真正的memcmp\n\n![image-20240725170939564](image-20240725170939564.png)\n\n为什么memcmp要保留它当memcmp函数的历史\n\n因为它是钩子\n\n\n\n.DASCTF段一大段爆红，首先想到smc\n\n![image-20240725171825345](image-20240725171825345.png)\n\n跟随IsDebuggerPresent()的脚步来到这个函数\n\n![image-20240725171845428](image-20240725171845428.png)\n\n找到smc的地方\n\n![image-20240725171906045](image-20240725171906045.png)\n\n下面是被加密的.DASCTF段\n\n![image-20240725171927351](image-20240725171927351.png)\n\n断点一打，开始调试\n\n.DASCTF段解密后恢复里面的几个关键函数\n\n这里，memcmp被hook了，它已经不是原来的memcmp了\n\n![image-20240725171947690](image-20240725171947690.png)\n\n这里是加密\n\n![image-20240725172013011](image-20240725172013011.png)\n\nTEA\n\n![image-20240725172026696](image-20240725172026696.png)\n\n此时如果回主函数找到memcmp，一路跟进，会来到这个地方，这是动态链接库里的memcmp\n\n![image-20240725172046275](image-20240725172046275.png)\n\n> 总得来说，被hook的函数会改变它原本的功能，所以main函数里的memcmp并不是比较，而是加密\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid De_tea(unsigned int *a1, unsigned int *a2)\n{\n\n    unsigned int i; // [esp+DCh] [ebp-2Ch]\n    int v4;     // [esp+E8h] [ebp-20h]\n    unsigned int v5;    // [esp+F4h] [ebp-14h]\n    unsigned int v6;    // [esp+100h] [ebp-8h]\n\n    v6 = *a1;\n    v5 = a1[1];\n\n    // for (i = 0; i < 16; ++i)\n    // {\n    //     v6 += (a2[1] + (v5 >> 5)) ^ (v4 + v5) ^ (*a2 + 16 * v5);\n    //     v5 += (a2[3] + (v6 >> 5)) ^ (v4 + v6) ^ (a2[2] + 16 * v6);\n    //     v4 -= 1640531527;\n    // }\n    v4 = 0 - 16 * 0x61C88647;\n    for (i = 0; i < 16; ++i)\n    {\n        v4 += 0x61C88647;\n        v5 -= (a2[3] + (v6 >> 5)) ^ (v4 + v6) ^ (a2[2] + 16 * v6);\n        v6 -= (a2[1] + (v5 >> 5)) ^ (v4 + v5) ^ (*a2 + 16 * v5);\n        \n    }\n\n    *a1 = v6;\n    a1[1] = v5;\n}\n\nint main(){\n\n    __int64 v1;      // rax\n    __int64 v3;      // [esp-8h] [ebp-24Ch]\n    int j;           // [esp+D0h] [ebp-174h]\n    size_t i;        // [esp+F4h] [ebp-150h]\n    char *v6;        // [esp+100h] [ebp-144h]\n    unsigned int v7; // [esp+124h] [ebp-120h] BYREF\n    int v8;          // [esp+128h] [ebp-11Ch]\n    int v9;          // [esp+12Ch] [ebp-118h]\n    int v10;         // [esp+130h] [ebp-114h]\n    unsigned char v11[41];   // [esp+13Ch] [ebp-108h] BYREF\n    int savedregs;   // [esp+244h] [ebp+0h] BYREF\n\n    v11[0] = 0xF9;\n    v11[1] = 0x4D;\n    v11[2] = 0x2B;\n    v11[3] = 0xBC;\n    v11[4] = 0x13;\n    v11[5] = 0xDD;\n    v11[6] = 0x13;\n    v11[7] = 0x62;\n    v11[8] = 0xC9;\n    v11[9] = 0xFC;\n    v11[10] = 0xFF;\n    v11[11] = 0x89;\n    v11[12] = 0x7D;\n    v11[13] = 0x4F;\n    v11[14] = 0xC9;\n    v11[15] = 0xF;\n    v11[16] = 0x63;\n    v11[17] = 0x1D;\n    v11[18] = 0x6D;\n    v11[19] = 0x52;\n    v11[20] = 0x50;\n    v11[21] = 0xFD;\n    v11[22] = 0x41;\n    v11[23] = 0xE3;\n    v11[24] = 0x33;\n    v11[25] = 0x76;\n    v11[26] = 0x28;\n    v11[27] = 0x97;\n    v11[28] = 0x38;\n    v11[29] = 0x36;\n    v11[30] = 0xF9;\n    v11[31] = 0x6B;\n    v11[32] = 0x90;\n    v11[33] = 0x39;\n    v11[34] = 0x14;\n    v11[35] = 0x83;\n    v11[36] = 0x2C;\n    v11[37] = 0xE2;\n    v11[38] = 0x2C;\n    v11[39] = 0x1F;\n    v11[40] = 0x0;\n\n    // unsigned int enc[10] = {\n    //     0xBC2B4DF9, 0x6213DD13, 0x89FFFCC9, 0x0FC94F7D, 0x526D1D63, 0xE341FD50, 0x97287633, 0x6BF93638,\n    //     0x83143990, 0x1F2CE22C};\n\n    // unsigned int key[4] = {\n    //     0x12345678, 0x09101112, 0x13141516, 0x15161718};\n    // v8 = *(v11 + 1);\n    // *v6 = v8;\n    unsigned char key[16] =\n        {\n            0x78, 0x56, 0x34, 0x12, 0x12, 0x11, 0x10, 0x09, 0x16, 0x15,\n            0x14, 0x13, 0x18, 0x17, 0x16, 0x15};\n\n    unsigned int *p = (unsigned int *)v11;\n\n    for (int i = 8; i >= 2;i -= 2){\n\n        // *&v11[4 * i + 4] ^= *v11;\n        // *&v11[4 * 1] ^= *v6;\n\n        \n        // *(unsigned int *)&v11[4 * i + 4] ^= p[1];\n        // *(unsigned int *)&v11[4 * i] ^= p[0];\n\n        *(unsigned int *)&v11[4 * i + 4] ^= v11[1];\n        *(unsigned int *)&v11[4 * i] ^= v11[0];\n\n        // enc[i] ^= enc[1];\n        // enc[i - 1] ^= enc[0];\n\n        De_tea(p, (unsigned int *)key);\n        // De_tea((unsigned int *)v11, (unsigned int *)key);\n    }\n\n    De_tea(p, (unsigned int *)key);\n\n    for(int i = 0; i < 40;++ i)\n        printf(\"%c\", v11[i]);\n\n    return 0;\n}\n```\n\n接下来表演的节目是神奇的指针\n\n当我将exp中间部分写成这样时\n\n```c++\n*(unsigned int *)&v11[4 * i + 4] ^= *(unsigned int *)v11[1];\n*(unsigned int *)&v11[4 * i] ^= *(unsigned int *)v11[0];\n```\n\n它的输出是这样的\n\n![image-20240725172154625](image-20240725172154625.png)\n\n当我写成这样时\n\n```C++\nunsigned int *p = (unsigned int *)v11;\n*(unsigned int *)&v11[4 * i + 4] ^= p[1];\n*(unsigned int *)&v11[4 * i] ^= p[0];\n```\n\n它的输出是这样的\n\n![image-20240725172217958](image-20240725172217958.png)\n\n当我写成这样时\n\n```C++\n*(unsigned int *)&v11[4 * i + 4] ^= v11[1];\n*(unsigned int *)&v11[4 * i] ^= v11[0];\n```\n\n它的输出是这样的\n\n![image-20240725172259527](image-20240725172259527.png)\n\n指针，很神奇吧\n","tags":["比赛复现"],"categories":["逆向"]},{"title":"临江仙","url":"/2024/07/25/临江仙/","content":"青山依旧在，几度夕阳红\n<!--more-->\n# 临江仙\n## 【明】杨慎\n滚滚长江东逝水，浪花淘尽英雄。是非成败转头空。青山依旧在，几度夕阳红。\n白发渔樵江渚上，惯看秋月春风。一壶浊酒喜相逢。古今多少事，都付笑谈中。\n","tags":["宋词"],"categories":["古文"]},{"title":"Frida操作大全","url":"/2024/04/10/Frida labs/","content":"Frida Labs全解\n\n<!--more-->\n# Frida labs\n\n## 参数解释\n\n```js\n-U 指定USB设备\n-f 指定app包名，通过spawn方式启动（就是重新启动的意思）\n-P 指定APP的pid\n--no-pause 不暂停\n-l 加载hook脚本\n```\n\n‍\n\n## 0x1 Hook修改被调用的方法的逻辑，返回值，传入参数\n\n使用随机数，对输入进行判断，如果输入数的满足一个表达式，就会打印出flag\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250413221718.png)\n\n于是这里就有两种思路了。第一种是 hook get_random 函数，让该函数的返回值变成一个固定的值，从而计算表达式的值\n\n第二种思路是 hook check 函数，直接将我们自己定义的值传入进去\n\n```js\nfunction hook() {\n\n    var MainActivity = Java.use(\"com.ad2001.frida0x1.MainActivity\"); //使用 Frida 的 Java.use() 方法获取目标类 MainActivity 的引用。\n    MainActivity.get_random.implementation = function () { //implementation 在 Frida 中是一个关键属性，用于覆盖原始 Java 方法的实现\n        return 0;\n    }\n}\n\n\nfunction hook2() {\n    var MainActivity = Java.use(\"com.ad2001.frida0x1.MainActivity\");\n    MainActivity.check.overload('int', 'int').implementation = function (a, b) { //overload用于指定参数，由于Java的方法可以重载，所以需要指定\n        console.log(\"Origin i and i2 = \", a, b); //console.log打印\n        return this.check(3, b); //我们自己将 i 的值定为 3 传入进去\n    }\n}\n\nfunction main() {\n\n    Java.perform(function () {\n        hook2();\n    })\n}\n\nsetImmediate(main);\n```\n\n注入\n\n```js\nfrida -U -f com.ad2001.frida0x1 -l hook.js\n```\n\n-U -f 缺一不可\n\n为什么\n\n缺少 -f\n\n```bash\nC:\\Users\\29660\\Desktop\\Frida\\Frida-Labs-main\\Frida-Labs-main\\Frida 0x1>frida -U com.ad2001.frida0x1 -l hook.js\n     ____\n    / _  |   Frida 16.4.10 - A world-class dynamic instrumentation toolkit\n   | (_| |\n    > _  |   Commands:\n   /_/ |_|       help      -> Displays the help system\n   . . . .       object?   -> Display information about 'object'\n   . . . .       exit/quit -> Exit\n   . . . .\n   . . . .   More info at https://frida.re/docs/home/\n   . . . .\n   . . . .   Connected to Android Emulator 5554 (id=emulator-5554)\nFailed to spawn: unable to find process with name 'com.ad2001.frida0x1' \n```\n\nFailed to spawn: unable to find process with name 'com.ad2001.frida0x1'表示没有Frida **找不到名为** **​`com.ad2001.frida0x1`​** **的进程，详见lab02**\n\n‍\n\n缺少-U\n\n```bash\nC:\\Users\\29660\\Desktop\\Frida\\Frida-Labs-main\\Frida-Labs-main\\Frida 0x1>frida -f com.ad2001.frida0x1 -l hook.js\n     ____\n    / _  |   Frida 16.4.10 - A world-class dynamic instrumentation toolkit\n   | (_| |\n    > _  |   Commands:\n   /_/ |_|       help      -> Displays the help system\n   . . . .       object?   -> Display information about 'object'\n   . . . .       exit/quit -> Exit\n   . . . .\n   . . . .   More info at https://frida.re/docs/home/\n   . . . .\n   . . . .   Connected to Local System (id=local)\nFailed to spawn: unable to find executable at 'com.ad2001.frida0x1'\n```\n\n说明 Frida **没有连接到 Android 模拟器**，而是连接到了你本地电脑（Windows），所以它以为是要在本地运行一个叫 `com.ad2001.frida0x1` 的可执行文件。\n\n‍\n\n## 0x2 Hook调用静态的未被调用的方法\n\n可以看到这里定义了一个 get_flag 方法，但是并没有在主函数中被调用\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250413222107.png)\n\n使用 frida 直接调用未被调用的静态方法\n\n```js\nsetImmediate(function () {\n\n    Java.perform(function () {\n\n        var a = Java.use(\"com.ad2001.frida0x2.MainActivity\")\n        a.get_flag(4919);\n\n    })\n\n})\n\n\n\nfunction hook() {\n    var MainActivity = Java.use(\"com.ad2001.frida0x2.MainActivity\");\n    MainActivity.get_flag(4919);\n}\n\nfunction main() {\n    Java.perform(function () {\n        hook();\n    })\n}\n\nsetImmediate(main);\n```\n\nhook的时候使用如下命令有可能会hook不上\n\n```js\nfrida -U -f com.ad2001.frida0x2 -l hook.js\n```\n\n原因是setImmediate(main);是程序启动后立即注入，可能会导致程序还没完全启动就注入了，所以hook不上\n\n解决办法是使用\n\n```js\nfrida -U 'frida 0x2' -l hook.js\n```\n\n那么，为什么将frida 0x2写成包名com.ad2001.frida0x2就不行呢\n\n```js\nfrida -U com.ad2001.frida0x2 -l hook.js\n```\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250411160833.png)\n\n这个命令尝试的是：**根据包名注入，默认是 spawn（启动）模式**。\n\n实际上这条命令是尝试 **spawn（启动）包名对应的 app**，但没写 `-f`，它又不是 attach 模式，就会失败。\n\n或者将hook代码中的\n\nsetImmediate(main);改成\n\nsetTimeout(main,1000);延迟启动\n\n```js\nfunction hook() {\n    var MainActivity = Java.use(\"com.ad2001.frida0x2.MainActivity\");\n    MainActivity.get_flag(4919);\n}\n\nfunction main() {\n    Java.perform(function () {\n        hook();\n    })\n}\n\n// setImmediate(main);\nsetTimeout(main, 1000);\n```\n\n‍\n\n## 0x3 更改类中的静态变量\n\nhook code的值\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250411171349.png)\n\n```js\nfunction hook() {\n    \n    var a = Java.use(\"com.ad2001.frida0x3.Checker\") //code的值在Checker类里\n    a.code.value = 512; //使用这一句修改静态变量的值\n}\n\nfunction main() {\n    \n    Java.perform(function () {\n        hook();\n    })\n}\n\nsetImmediate(main);\n```\n\n思考：\n\na是什么\n\na.code.value具体是什么意思\n\n以下内容来自GPT\n\n> 在这段 Frida 脚本中：\n>\n> ```javascript\n> var a = Java.use(\"com.ad2001.frida0x3.Checker\")\n> ```\n>\n> ### `a` 是什么？\n>\n> 👉 **​`a`​** **是一个 Frida 创建的 Java 类代理对象（Java class wrapper）** ，你可以把它当成是一个“控制器”或者“代理”，用来访问和操作 Java 中的类 `com.ad2001.frida0x3.Checker` 的静态字段、静态方法、实例方法，甚至可以 hook 它的方法。\n>\n> ---\n>\n> ### 类比一下：\n>\n> 在 Java 代码中你可能会这样用一个类：\n>\n> ```java\n> Checker.code = 512;\n> ```\n>\n> 在 Frida 中，为了达到类似的效果，我们写：\n>\n> ```javascript\n> var a = Java.use(\"com.ad2001.frida0x3.Checker\")\n> a.code.value = 512;\n> ```\n>\n> ---\n>\n> ### 更具体地说：\n>\n> - ​`Java.use(\"...\")` 会返回一个 **Frida 的 Java 类接口（wrapper）**\n> - 这个对象不是类的一个实例，而是一个可以操作 **类本身（静态成员）或创建实例** 的对象。\n> - 如果你需要创建类的实例，你可以这样写：\n>\n>   ```javascript\n>   var instance = a.$new();  // 等于 Java 里的 new Checker()\n>   ```\n>\n> ---\n>\n> ### 所以总结一下：\n>\n> |名称|解释|\n> | ------| --------------------------------------|\n> |​`a`​|Frida 中的类包装对象，表示`Checker`类|\n> |​`a.code.value`​|表示访问并修改类中`code`这个静态字段的值|\n> |​`a.$new()`​|（可选）表示创建这个类的一个新实例|\n\n‍\n\n## 0x4 调用非MainActivity,非静态方法\n\n​`MainActivity`里没有任何东西\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250412170532.png)\n\n定义了一个Check类，里面有get_flag方法\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250412170610.png)\n\n想调用这个get_flag方法，必须实例化一个check类对象，在frida中可以用以下脚本实现\n\n```js\nfunction hook() {\n    \n    var c = Java.use(\"com.ad2001.frida0x4.Check\");\n    var c_check = c.$new();   //实例化check类对象 相当于Java里写 c c_check = new c();\n \n    var flag = c_check.get_flag(1337);\n    console.log(flag);\n}\n\nfunction main() {\n    \n    Java.perform(function () {\n        \n        hook();\n    })\n}\n\nsetImmediate(main);\n```\n\n运行结果如下\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250412170950.png)\n\n## 0x5 调用MainActivity中的非静态方法\n\n在 0x2 中，我们使用frida调用了静态方法\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250413192625.png)\n\n但在本次，这是一个非静态方法\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250413192705.png)\n\nJava中静态方法可以直接调用，而非静态方法必须实例化一个对象之后才能调用\n\n```js\npublic class Hello {\n\n    // 静态方法\n    public static void sayStatic() {\n        System.out.println(\"我是静态方法\");\n    }\n\n    // 非静态方法\n    public void sayInstance() {\n        System.out.println(\"我是非静态方法\");\n    }\n\n    public static void main(String[] args) {\n        // 调用静态方法：不需要创建对象\n        Hello.sayStatic();\n\n        // 调用非静态方法：必须先创建对象\n        Hello h = new Hello();\n        h.sayInstance();\n    }\n}\n```\n\n我们直接用 0x2 的脚本hook一下\n\n```js\nfunction hook() {\n    var MainActivity = Java.use(\"com.ad2001.frida0x5.MainActivity\");\n    MainActivity.flag(1337);\n}\n\nfunction main() {\n    Java.perform(function () {\n        hook();\n    })\n}\n\nsetImmediate(main);\n```\n\n哦豁，报错了\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250413194308.png)\n\n以下解释来自SWDD师傅\n\n> 直接使用Frida创建MainActivity或任何Android组件可能会很棘手，因为Android的生命周期和线程规则。Android组件，如Activity子类，依赖于应用程序上下文进行正确运行。在Frida中，您可能缺少必要的上下文。Android UI组件通常需要具有关联Looper的特定线程。如果涉及UI任务，请确保在具有活动Looper的主线程上执行。活动是较大的Android应用程序生命周期的一部分。创建MainActivity的实例可能需要应用处于特定状态，并且通过Frida管理整个生命周期可能并不直接。总之，为MainActivity创建实例并不是一个好主意。\n\n通俗点来说就是，\n\n> **用Frida直接创建 MainActivity 或其他 Android 组件（比如 Activity）是很麻烦的，甚至是不可行的。**\n\n原因是这样的：\n\n1. **Activity 需要上下文（Context）才能正常工作**：就像你造房子要有地基一样，Activity 这种组件运行的时候，需要依赖应用程序提供的运行环境（就是 Context）。在 Frida 里，你是“旁观者”，而不是“房子的主人”，所以没法轻松提供这个环境。\n2. **UI 相关的代码必须在主线程（带 Looper 的线程）里跑**：Android 要求所有跟界面有关的操作都得在“主线程”里运行，这个线程有个叫 Looper 的消息循环系统。在 Frida 里，如果你随便在哪个线程里跑 UI 代码，程序很可能直接崩掉。\n3. **Activity 的生命周期很复杂**：系统会自动帮 Activity 调用一系列方法，比如 onCreate、onStart、onResume 等。这一整套流程是系统控制的。如果你自己用 Frida 去“强行”创建一个 Activity 实例，系统其实并不知道它存在，所以它无法正常工作。\n\n那么应该怎么办呢\n\nSWDD说\n\n> 当Android应用程序启动时，系统会创建MainActivity的一个实例（或AndroidManifest.xml文件中指定的启动器活动）。创建MainActivity实例是Android应用程序生命周期的一部分。因此，我们可以使用frida获取MainActivity的实例，然后调用flag()方法来获取我们的标志。\n\n让我们看看GPT怎么说\n\n> ---\n>\n> ## 📱 正常来说，Android 应用是怎么启动的？\n>\n> 1. 当你点击某个 App 图标时，\n> 2. Android 系统就会去看这个 App 的 `AndroidManifest.xml` 文件，\n> 3. 找到标注为「启动入口」的 Activity（比如 `MainActivity`），\n> 4. 然后系统会**自动创建这个 Activity 的实例**，并调用它的一系列生命周期方法（比如 `onCreate()`、`onResume()` 等）。\n>\n> ---\n>\n> ## 🧠 那这段话的核心意思就是：\n>\n>> **你自己不用 new 一个 MainActivity，系统已经帮你创建好了！**\n>>\n>\n> 所以与其自己创建一个可能不完整的实例（会有很多问题），**不如直接去“拿到”系统已经创建的那个实例，然后调用你想要的函数，比如** **​`flag()`​** ​ **。**\n>\n> ## ✅ 总结一下，通俗点说就是：\n>\n>> “Android 系统会自动帮你创建 MainActivity 的实例，所以你**不需要自己造一个**。用 Frida 可以直接找到这个已经存在的实例，**然后调用你想要的方法（比如** **​`flag()`​** ​ **）来拿 flag。”**\n>>\n\n有这样一个模板\n\n```js\nJava.performNow(function() {\n  Java.choose('<包名>.<类名>', {\n    onMatch: function(instance) {\n      // 待办事项\n    },\n    onComplete: function() {}\n  });\n});\n```\n\n> - **onMatch**\n>\n>   - ​`onMatch`回调函数在`Java.choose`操作期间找到指定类的每个实例时执行。\n>   - 这个回调函数接收当前实例作为它的参数。\n>   - 您可以在`onMatch`回调中定义自定义操作，以在每个实例上执行。\n>   - ​`function(instance) {}`，`instance`参数表示目标类的每个匹配实例。您可以使用任何其他名称。参数 `instance` 就是这个 MainActivity 的对象，你可以在这里调用它的函数，比如 `instance.flag()`​\n> - **onComplete**\n>\n>   - ​`onComplete`回调在`Java.choose`操作完成后执行操作或清理任务。此块是可选的，如果您在搜索完成后不需要执行任何特定操作，则可以选择将其留空。\n\n尝试使用该模板寻找MainActivity实例\n\n```js\nfunction hook() {\n\n    Java.choose('com.ad2001.frida0x5.MainActivity', {\n        \n        onMatch: function (instance) {\n            console.log(\"Sucess found!!!\");\n        },\n        onComplete: function () {\n            console.log(\"end\");\n        }\n    });\n}\n\nfunction main() {\n    Java.perform(function () {\n        hook();\n    })\n}\n\nsetImmediate(main);\n```\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250413203112.png)\n\n在这里还发现个问题，当使用如下命令启动frida时，只会打印一个 end ，hook不上，需要重新修改一下脚本（例如注释掉某一行再加上）\n\n```js\nfrida -U -f com.ad2001.frida0x5 -l lab05.js\n```\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250413203858.png)\n\n原因其实跟 0x2 一样，由于脚本是立即注入，app还来不及创建MainActivity实例，自然就没找到\n\n解决办法也跟 0x2 一样，这里就不再赘述\n\n‍\n\n## 0x6 MainActivity中的非静态方法且参数通过非MainActivity非静态方法传递\n\nMainActivity中的非静态方法 get_flag ，并且参数是通过 Checker 类对象 A 来传递的\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250413210156.png)\n\nChecker类如下\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250413210311.png)\n\n所以这题就是0x5 0x4 0x3的结合，但是在 0x3 中，变量为静态变量，所以需要这里需要创建一个类的对象来对变量进行更改\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250413210502.png)\n\n```js\nfunction hook() {\n\n    Java.choose(\"com.ad2001.frida0x6.MainActivity\", {\n        \n        onMatch: function (MainActivity) {\n            \n            var c = Java.use(\"com.ad2001.frida0x6.Checker\")\n            var A = c.$new();\n\n            A.num1.value = 1234;\n            A.num2.value = 4321;\n\n            console.log(\"success\");\n            MainActivity.get_flag(A);\n        },\n        onComplete: function () {\n            console.log(\"end\");\n        }\n    });\n\n}\n\nfunction main() {\n\n    Java.perform(function () {\n        hook();\n    })\n}\n\n// setImmediate(main);\nsetTimeout(main, 1000);\n```\n\n‍\n\n## 0x7 Hook构造函数\n\n构造函数是 Java 类中的一种特殊方法，它的作用是：**在创建对象的时候用来初始化对象的属性**。\n\n先举个例子来了解一下森莫是Java中的构造函数\n\n```Java\npublic class Dog {\n    String name;\n    int age;\n\n    // 构造函数\n    public Dog(String n, int a) {\n        name = n;\n        age = a;\n    }\n\n    // 普通方法\n    public void bark() {\n        System.out.println(name + \" 汪汪叫！\");\n    }\n\n    public void showInfo() {\n        System.out.println(\"这只狗叫 \" + name + \"，它 \" + age + \" 岁了。\");\n    }\n\n    public static void main(String[] args) {\n        Dog d = new Dog(\"小黑\", 3);  // 调用构造函数，初始化对象       Dog（第一个）👉 表示变量 d 的 类型，也就是类名，说明 d 是一个 Dog 类型的对象。\n                                    //new Dog(\"小黑\", 3)（后面这个）👉 是 调用构造函数，创建一个新的 Dog 对象，并传入两个参数。\n        d.bark();                   // 调用普通方法\n        d.showInfo();               // 调用普通方法\n    }\n}\n\n```\n\n来看本题，调用了flag方法，并且通过Checker构造函数对 num1 和 num2 赋值为 123 和 321\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250413213132.png)\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250413213246.png)\n\n在Frida中使用 $init 关键字来 hook 构造函数\n\n```js\nfunction hook() {\n\n    var Checker = Java.use(\"com.ad2001.frida0x7.Checker\");\n    Checker.$init.implementation = function (a, b) {\n\n    //  Checker.$init 是这个类的 构造函数（constructor）。\n    //  .implementation = function (a, b) 表示你要“劫持”这个构造函数，用你自己的实现来替代原来的。\n    //  a, b 就是原本传给构造函数的两个参数。\n\n        console.log(\"Origin num\", a, b);\n        this.$init(666, 666);    //this.$init(...) 表示“用原本的方式继续初始化对象，但用我给的参数”\n        console.log(\"success\");  \n    }\n}\n\nfunction main() {\n    Java.perform(function () {\n        hook();\n    })\n}\nsetImmediate(main);\n```\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250413215324.png)\n\n写到这我有点好奇如果使用 0x1 的方法直接去 hook 构造函数会怎样\n\n来吧，实践出真知\n\n```js\nfunction hook() {\n    var Ch = Java.use(\"com.ad2001.frida0x7.Checker\");\n    Ch.Checker.overload('int', 'int').implementation = function (a, b) { \n        console.log(\"Origin num\", a, b); //console.log打印\n        return this.Checker(666, 666);\n    }\n}\n\nfunction main() {\n    Java.perform(function () {\n        hook();\n    })\n}\nsetImmediate(main);\n```\n\n哈哈，报错了，cannot read property 'overload' of undefined 说明试图 hook 的 Java 方法并没有找到\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250413215448.png)\n\n然后我又好奇，如果使用 0x3 的方法直接改变 num1 和 num2 会怎样\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250413215954.png)\n\n```js\nfunction hook() {\n\n    var Checker = Java.use(\"com.ad2001.frida0x7.Checker\");\n    Checker.$init.implementation = function (a, b) {\n\n    //  Checker.$init 是这个类的 构造函数（constructor）。\n    //  .implementation = function (a, b) 表示你要“劫持”这个构造函数，用你自己的实现来替代原来的。\n    //  a, b 就是原本传给构造函数的两个参数。\n\n        console.log(\"Origin num\", a, b);\n        // this.$init(666, 666);    //this.$init(...) 表示“用原本的方式继续初始化对象，但用我给的参数”\n        Checker.num1.value = 666;\n        Checker.num2.value = 666;\n        console.log(\"success\");\n    }\n}\n\nfunction main() {\n    Java.perform(function () {\n        hook();\n    })\n}\nsetImmediate(main);\n```\n\n哈哈，果然又报错了  Error: Cannot access an instance field without an instance 表示试图访问 `Checker.num1`，但这是 **实例字段（成员变量）** ，你必须通过一个具体对象（也就是 `this`）来访问它\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250413220144.png)\n\n改成这样或许会比初代脚本好理解一些，跟 0x1 也更像\n\n```js\nfunction hook() {\n\n    var Checker = Java.use(\"com.ad2001.frida0x7.Checker\");\n    Checker.$init.overload('int', 'int').implementation = function (a, b) {\n        console.log(\"Origin num:\", a, b);\n\n        // 调用原始构造函数初始化对象\n        this.$init(a, b);\n\n        // 修改成员变量\n        this.num1.value = 666;\n        this.num2.value = 666;\n\n        console.log(\"Success: num1 and num2 changed to 666\");\n    };\n}\n\nfunction main() {\n    Java.perform(function () {\n        hook();\n    })\n}\nsetImmediate(main);\n```\n\n‍\n\n## 0x8 Hook Native层中调用的函数并且读取传入的参数\n\n从本章开始进入 Native层\n\n模板如下\n\n```js\nInterceptor.attach(targetAddress, {\n    onEnter: function (args) {\n        console.log('Entering ' + functionName);\n        // Modify or log arguments if needed\n    },\n    onLeave: function (retval) {\n        console.log('Leaving ' + functionName);\n        // Modify or log return value if needed\n    }\n});\n```\n\n它的作用是：\n\n**当程序运行到某个特定函数（地址为** **​`targetAddress`​**​ **）时：**\n\n- **函数刚进入时（onEnter）** ：打印一句话，说“我进来了”；\n- **函数执行完返回时（onLeave）** ：再打印一句“我出去了”。\n\n每行的意思\n\n```js\nInterceptor.attach(targetAddress, {\n```\n\n用 Frida 的 `Interceptor.attach` 来**拦截（hook）某个函数地址**。这个地址是你想观察或修改的函数位置（`targetAddress`）。\n\n```js\n    onEnter: function (args) {\n        console.log('Entering ' + functionName);\n        // Modify or log arguments if needed\n    },\n```\n\n当程序刚进入这个函数时，会执行 `onEnter` 这个回调。  \n你可以：\n\n- 打印日志（像现在这样打印“正在进入函数”）；\n- 查看和修改传入参数（`args` 是参数列表）。\n\n  ‍\n\n```js\n    onLeave: function (retval) {\n        console.log('Leaving ' + functionName);\n        // Modify or log return value if needed\n    }\n```\n\n当函数执行完准备返回时，会执行 `onLeave`。  \n你可以：\n\n- 打印返回值；\n- 修改返回值（`retval` 是返回值）。\n\n‍\n\n需要获取targetAddress我们可以使用如下API\n\n1. ​`Module.enumerateExports()`  \n    通过调用 Module.enumerateExports()，我们可以获取到导出函数的名称、地址以及其他相关信息。这些信息对于进行函数挂钩、函数跟踪或者调用其他函数都非常有用。\n2. ​`Module.getExportByName()`  \n    当我们知道要查找的导出项的名称但不知道其地址时，可以使用 Module.getExportByName()。通过提供导出项的名称作为参数，这个函数会返回与该名称对应的导出项的地址。\n3. ​`Module.findExportByName()`  \n    这与 Module.getExportByName() 是一样的。唯一的区别在于，如果未找到导出项，Module.getExportByName() 会引发异常，而 Module.findExportByName() 如果未找到导出项则返回 `null`​\n4. ​`Module.getBaseAddress()`  \n    通过调用 Module.getBaseAddress() 函数，我们可以获取指定模块的基址地址，然后可以基于这个基址地址进行偏移计算，以定位模块内部的特定函数、变量或者数据结构\n5. ​`Module.enumerateImports()`  \n    通过调用 Module.enumerateImports() 函数，我们可以获取到指定模块导入的外部函数或变量的名称、地址以及其他相关信息。\n\n‍\n\n使用 Module.enumerateImports(\"libfrida0x8.so\") 查看导入表\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250414155153.png)\n\n使用Module.findExportByName(\"libc.so\",\"strcmp\");来获取strcmp的地址\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250414155318.png)\n\n来看这题\n\n加载了一个 frida0x8\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250414174714.png)\n\nso文件里有一个 strcmp 函数，第二个参数 s2 就是经过处理后的正确的 flag ，所以我们需要把strcmp函数的第二个参数hook出来\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250414174755.png)\n\n我先按照我自己的想法写了一个脚本\n\n```js\nfunction hook() {\n\n    var target = Module.findExportByName(\"libc.so\", \"strcmp\"); //查找strcmp的地址\n    console.log(\"strcmp addr is :\", target.toString(16));\n\n    Interceptor.attach(target, {\n        onEnter: function (args) {\n            console.log(Memory.readUtf8String(args[1])); //打印strcmp的第二个参数\n        },\n\n        onLeave: function (retval) {\n            \n        }\n    })\n}\n\n\nfunction main() {\n    Java.perform(function () {\n        hook();\n    })\n}\nsetImmediate(main);\n```\n\n输出如下\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250414180856.png)\n\n这里其实是因为，我以为我hook的是特定的某一个strcmp，实际上这个 hook 是生效于所有调用 `libc.so!strcmp` 的地方，无论是 native 调用还是通过 JNI 被 Java 调用的 native 方法，**都会被拦截**\n\n所以导致了这种情况\n\n所以要加一个判断，当strcmp的第一个参数包含某个数（例如666）时，就打印第二个参数的结果，使我们的目标更加“精确”\n\n修改脚本如下\n\n```js\nfunction hook() {\n\n    var target = Module.findExportByName(\"libc.so\", \"strcmp\"); //查找strcmp的地址\n    console.log(\"strcmp addr is :\", target.toString(16));\n\n    Interceptor.attach(target, {\n        onEnter: function (args) { //args只是我对参数起的名字，可以改成任何别的\n\n            var input = Memory.readUtf8String(args[0]);\n\n            if (input.includes(\"666\")) {\n                console.log(Memory.readUtf8String(args[1])); //打印strcmp的第二个参数\n            }\n            \n        },\n\n        onLeave: function (retval) {\n            \n        }\n    })\n}\n\n\nfunction main() {\n    Java.perform(function () {\n        hook();\n    })\n}\nsetImmediate(main);\n```\n\n> 在 Frida 中：\n>\n> - ​`Memory` 是 Frida 的一个全局对象，提供了访问目标进程内存的方法。\n> - 它可以用来：\n>\n>   - 读取内存（如 `Memory.readUtf8String(ptr)`、`Memory.readByteArray(ptr, size)`）\n>   - 写入内存（如 `Memory.writeUtf8String(ptr, \"hello\")`）\n>\n> 你用的 `Memory.readUtf8String()` 是它最常用的函数之一，专门处理 C 字符串（以 null 结尾的 UTF-8 字符串）。\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250414181913.png)\n\n‍\n\n## 0x9 Hook Native层函数的返回值\n\ncheck_flag的值如果是1337就打印flag\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250414190811.png)\n\nnative层中的该函数的返回值是1\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250414190831.png)\n\n修改该函数的返回值即可\n\n```js\nfunction hook() {\n\n    var target = Module.enumerateExports(\"liba0x9.so\")[0][\"address\"];\n\n    console.log(\"addr is :\", target);\n\n    Interceptor.attach(target, {\n        onEnter: function (args) {    \n        },\n\n        onLeave: function (retval) {\n\n            console.log(\"Origin retval is :\", retval);\n            retval.replace(1337);\n        }\n    })\n}\n\n\nfunction main() {\n    Java.perform(function () {\n        hook();\n    })\n}\nsetImmediate(main);\n```\n\n思考：\n\n这一句\n\n```js\nvar target = Module.enumerateExports(\"liba0x9.so\")[0][\"address\"];\n```\n\n在 0x8 中使用的是\n\n```js\nvar target = Module.findExportByName(\"libc.so\", \"strcmp\");\n```\n\n我的猜想是，在 0x8 中，我们使用\n\nModule.enumerateImports(\"libfrida0x8.so\")查看导入表，而在该题目中，由于hook的是自己的函数，所以需要使用Module.enumerateExports(\"liba0x9.so\")查看导出表\n\n> - **导入表（Imports）** ：  \n>   是这个库 **调用别人的函数**，通常是系统函数，比如 `libc.so` 里的 `malloc`、`printf`、`strlen` 等。\n> - **导出表（Exports）** ：  \n>   是这个库 **暴露给别人用的函数**，很多时候是你自己写的，比如 `Java_com_example_myapp_NativeMethod` 这种 native 接口，或者一些插件调用的入口函数。\n\n查看导出表\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250414191954.png)\n\n尝试改成跟 0x8 中差不多的写法\n\n```js\nvar target = Module.findExportByName(\"liba0x9.so\", \"Java_com_ad2001_a0x9_MainActivity_check_1flag\");\n```\n\n好吧这样也可以，实践出真知了\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250414192036.png)\n\n还是解释一下这一句吧\n\n```js\nvar target = Module.enumerateExports(\"liba0x9.so\")[0][\"address\"];\n```\n\n> - ​`Module.enumerateExports(\"liba0x9.so\")`  \n>   这会列出 `liba0x9.so` 这个 native 库里导出的所有函数（也就是那些对外开放可以调用的函数），返回一个包含信息的数组，比如：\n>\n>   ```js\n>   [\n>     {name: \"check_flag\", address: ptr(\"0x12345678\"), type: \"function\"},\n>     {name: \"init\", address: ptr(\"0x12345690\"), type: \"function\"},\n>     ...\n>   ]\n>   ```\n> - ​`[0][\"address\"]`  \n>   表示取这个导出函数列表里的**第一个函数的地址**，也就是 `check_flag` 的地址（假设第一个刚好是它）。这一行把这个地址赋值给 `check_flag` 变量。[0]表示索引\n\n‍\n\n## 0xA Hook Native层未被调用的方法\n\n从本章开始使用模拟器会闪退，这里使用的环境是Redmi K60 安卓14 已ROOT\n\n可以使用如下模板\n\n```js\nvar native_adr = new NativePointer(<address_of_the_native_function>);\nconst native_function = new NativeFunction(native_adr, '<return type>', ['argument_data_type']);\nnative_function(<arguments>);\n```\n\n‍\n\n让我们来逐行解释一下\n\n```js\nvar native_adr = new NativePointer(<address_of_the_native_function>);\n```\n\n这一句的意思是，我们知道一个原生函数在内存中的地址（比如 0x12345678），把它封装成一个 `NativePointer` 类型的对象，好让 Frida 能识别这个地址。`<address_of_the_native_function>` 是手动填进去的地址，通常是通过逆向分析（IDA、Frida hook 等）找到的函数地址。\n\n‍\n\n```js\nconst native_function = new NativeFunction(native_adr, '<return type>', ['argument_data_type']);\n```\n\n这一行的意思是，把这个地址（native\\_adr）对应的函数转换成 JavaScript 能调用的函数。\n\n- ​`<return type>` 表示这个函数的返回值类型，比如 `'int'`、`'void'`、`'pointer'` 等。\n- ​`['argument_data_type']` 表示这个函数的参数类型列表，比如 `['int', 'pointer']`。\n\n所以这一行的作用是：**用 Frida 的** **​`NativeFunction`​** **包装原生函数，让你可以像普通 JS 函数那样去调用它。**\n\n‍\n\n```js\nnative_function(<arguments>);\n```\n\n最后直接调用这个原生函数，传入你需要的参数（这些参数要和上面声明的参数类型匹配）\n\n现在来看看例题\n\nJava层并不能看到什么有用的，只是加载了`stringFromJNI()`​\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250415201736.png)\n\n我们来看看native层，stringFromJNI也没什么有用的信息，但是有一个get_flag函数可以打印flag\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250415201824.png)\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250415201847.png)\n\n于是思路就是，利用上面的模板 hook 出get_flag函数\n\n模仿 0x9 中使用 Module.enumerateExports(\"libfrida0xa.so\") 查看导出表，发现导出表非常之长，直接使用var target = Module.enumerateExports(\"liba0x9.so\")[0][\"address\"];进行索引会有点麻烦，所以我们换一种方法\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250415203957.png)\n\n由于ALSR（地址随机化）的问题，所以我们先使用`Module.findBaseAddress(\"libfrida0xa.so\");`查看一下基地址\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250415203452.png)\n\n可以构造如下循环\n\n```js\n\tvar base_addr = Module.findBaseAddress(\"libfrida0xa.so\");\n  \tvar exports = Module.enumerateExports(\"libfrida0xa.so\");\n\n    var target = null;\n\n\tfor (var i = 0; exports[i] != null; i++){\n        \n        if (exports[i][\"name\"] == \"_Z8get_flagii\") {\n\n            console.log(\"function get_flag : \", exports[i][\"address\"]);\n            console.log((exports[i][\"address\"] - base_addr).toString(16));\n\n            target = exports[i][\"address\"];\n\n        }\n\n    }\n```\n\n这里我们找到基地址后，遍历导出表，如果在导出表中找到了 get_flag 函数，就打印出 get_flag 函数的绝对地址\n\n同时由于我们知道了绝对地址和基地址，于是我们就可以顺便把偏移地址也打印出来\n\n偏移 = 函数地址 - 模块基地址\n\n这样我们就找到了我们需要 hook 的目标函数的地址\n\n‍\n\n这里还有个问题，为什么 get_flag 要写成 \"_Z8get_flagii\" 呢\n\n这其实是C++ 的 **name mangling（名字改编 / 名字重整）问题**\n\n什么是 Name Mangling？\n\n在 **C++ 中**，函数名会被编译器**自动改写**成一串带有额外信息的名字，称为 **mangled name（重整名字）** 。\n\n这是因为 **C++ 支持函数重载（同名函数，不同参数）** ，而汇编语言、链接器、操作系统等底层东西并不支持这一特性。\n\n举个例子：\n\n```cpp\nint add(int a, int b);\nfloat add(float a, float b);\n```\n\n这两个函数在 C++ 中是合法的，因为它们参数不同。但如果你不做 name mangling，它们在汇编/符号表里都叫 `add`，系统就不知道你到底想调用哪个。\n\n所以编译器会把它们改名：\n\n```\nint add(int, int)       --> _Z3addii\nfloat add(float, float) --> _Z3addff\n```\n\n这就是 name mangling。\n\n由于我们主要研究frida hook，这个问题就不过多赘述\n\n‍\n\n回归正题，知道了我们的目标地址后就可以直接写脚本啦，利用上面的模板\n\n```js\nfunction hook() {\n\n    var base_addr = Module.findBaseAddress(\"libfrida0xa.so\");\n    var exports = Module.enumerateExports(\"libfrida0xa.so\");\n\n    var target = null;\n\n    for (var i = 0; exports[i] != null; i++){\n        \n        if (exports[i][\"name\"] == \"_Z8get_flagii\") {\n\n            console.log(\"function get_flag : \", exports[i][\"address\"]);\n            console.log(\"base addr is:\", (exports[i][\"address\"] - base_addr).toString(16));\n\n            target = exports[i][\"address\"];\n\n        }\n\n    }\n\n    var get_flag_ptr = new NativePointer(target);\n    const My_get_flag = new NativeFunction(get_flag_ptr, 'char', ['int', 'int']);\n\n\n    var flag = My_get_flag(1, 2);\n    console.log(flag);\n\n\n}\n\nfunction main() {\n    Java.perform(function () {\n        hook();\n    })\n}\n\nsetImmediate(main)\n```\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250415211743.png)\n\n由于打印出的是函数的返回值，而且so文件中使用的函数是__android_log_print，所以flag在logcat中可以看到\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250415211847.png)\n\n思考：能否直接在frida面板中打印出flag？\n\n有的兄弟，有的\n\n还记得lab0x8的内容吗，我们可以Hook `__android_log_print`这个函数，直接截获 flag\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250415212343.png)\n\nflag的内容是`__android_log_print`的第四个参数，所以我们直接读取它的第四个参数然后打印出来就行\n\n完整hook并打印flag的脚本如下\n\n```js\nfunction hook() {\n\n    var base_addr = Module.findBaseAddress(\"libfrida0xa.so\");\n    var exports = Module.enumerateExports(\"libfrida0xa.so\");\n\n    var target = null;\n\n    for (var i = 0; exports[i] != null; i++){\n        \n        if (exports[i][\"name\"] == \"_Z8get_flagii\") {\n\n            console.log(\"function get_flag : \", exports[i][\"address\"]);\n            console.log(\"base addr is:\", (exports[i][\"address\"] - base_addr).toString(16));\n\n            target = exports[i][\"address\"];\n\n        }\n\n    }\n\n    var get_flag_ptr = new NativePointer(target);\n    const My_get_flag = new NativeFunction(get_flag_ptr, 'char', ['int', 'int']);\n\n    var print_addr = Module.findExportByName(null, \"__android_log_print\"); //hook __android_log_print函数\n    Interceptor.attach(print_addr, {\n        \n        onEnter: function (args) {\n            \n            var flagPtr = args[3];\n            var flag = flagPtr.readCString();\n            console.log(flag); //读取并打印flag内容\n        },\n\n        onLeave: function (retval) {\n            \n        }\n    });\n\n    var flag = My_get_flag(1, 2);\n    console.log(flag);\n\n\n}\n\nfunction main() {\n    Java.perform(function () {\n        hook();\n    })\n}\n\nsetImmediate(main)\n```\n\n‍\n\n## 0xB 更改Native层的汇编指令\n\n先来看x86下的模板\n\n```js\nvar writer = new X86Writer(opcodeaddr);\nMemory.protect(opcodeaddr, 0x1000, \"rwx\");\ntry {\n \n  writer.flush();\n \n} finally {\n \n  writer.dispose();\n}\n```\n\n我们来解释一下\n\n```js\nvar writer = new X86Writer(opcodeaddr);\n```\n\n- 创建了一个写指令的“写手”对象，叫 `writer`。\n- ​`X86Writer` 是 Frida 提供的一个类，用来向指定内存地址写入 x86 汇编指令。\n- ​`opcodeaddr` 是你想修改的地址，比如某个函数开头或者中间的指令地址。\n\n```js\nemory.protect(opcodeaddr, 0x1000, \"rwx\");\n```\n\n- 把从 `opcodeaddr` 开始的一段内存（大小为 `0x1000` 字节，也就是一页）设置为可读（r）、可写（w）、可执行（x）。\n- 默认情况下，程序的代码区域一般是只读的；要想修改它，就得先把它“解锁”。\n\n```js\ntry { writer.flush(); }\n```\n\ntry块中我们可以插入要修改/添加的x86指令。X86Writer实例提供了各种方法来插入各种x86指令。\n\n​`writer.flush();`​\n\n- 插入指令后，调用`flush`方法将更改应用到内存中。这确保修改后的指令被写入内存位置。\n\n```js\nfinally { writer.dispose(); }\n```\n\n最后无论是否出错，都调用 `dispose()` 来释放资源。否则可能会造成内存泄漏\n\n对于x86而言，我们可以查阅如下文档\n\n[JavaScript API | Frida • A world-class dynamic instrumentation toolkit](https://frida.re/docs/javascript-api/#x86writer)\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250415215645.png)\n\n对于arm64而言，我们可以查阅如下文档\n\n[JavaScript API | Frida • A world-class dynamic instrumentation toolkit](https://frida.re/docs/javascript-api/#arm64writer)\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250415215657.png)\n\n接下来让我们看看例题，使用的架构为arm64架构\n\nJava层依旧是什么都没有\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250415215808.png)\n\nnative层中的MainActivity伪代码界面什么都没有，很明显这不正常\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250415215843.png)\n\n看看控制流，发现这里构成了一个永假跳转指令，导致我们的IDA反编译出错\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250415215932.png)\n\n那么，我们直接nop掉这个B.NE即可\n\nIDA查看偏移地址是在0x15248处\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250415220023.png)\n\n开始hook\n\n```js\nfunction hook() {\n\n    var base_addr = Module.getBaseAddress(\"libfrida0xb.so\");\n\n    console.log(\"Base address : \", base_addr);\n    var BNE_addr = base_addr.add(0x15248);\n\n    Memory.protect(base_addr, 0x1000, \"rwx\");\n\n    var writer = new Arm64Writer(BNE_addr);\n\n    try {\n        writer.putNop();\n        writer.flush();\n        console.log(\"Success!!\");\n    } finally {\n        writer.dispose();\n    }\n}\n\nfunction main() {\n    Java.perform(function () {\n        hook();\n    })\n}\n\nsetTimeout(main, 1000);\n```\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250415220406.png)\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250415220417.png)\n\n同样是需要到logcat中查看flag\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250415220448.png)\n\n‍\n\n‍\n\n‍\n\n‍\n\n‍\n\n‍\n\n‍\n\n‍\n\n‍\n\n‍\n\n‍\n\n‍\n","tags":["移动安全"],"categories":["逆向"]}]
[{"title":"安卓Native层函数注册","url":"/2025/10/15/Native函数注册/","content":"\n当执行一个 Java 的 native 方法时，虚拟机是怎么知道该调用 so 中的哪个方法呢？这就需要用到注册的概念了，通过注册，将指定的 native 方法和 so 中对应的方法绑定起来（函数映射表），这样就能够找到相应的方法了。  \n注册分为 **静态注册 和 动态注册**两种。默认的实现方式即静态注册\n\n<!--more-->\n\n\n\n## 静态注册\n\nJava 方法与 C 函数通过**名字规则**自动对应，C/C++ 的函数名必须严格遵循命名规范：\n\n```python\nJava_包名_类名_方法名(JNIEnv* env, jobject obj, ...)\n```\n\n### 例子\n\n```python\npackage com.example;\n\npublic class MyClass {\n    public native void sayHello();\n    static {\n        System.loadLibrary(\"native-lib\");\n    }\n}\n```\n\nnative代码\n\n```python\n#include <jni.h>\n#include <stdio.h>\n\nJNIEXPORT void JNICALL\nJava_com_example_MyClass_sayHello(JNIEnv* env, jobject obj) {\n    printf(\"Hello from C!\\n\");\n}\n```\n\n### 逆向\n\n在Java层可以看到Native层注册的函数\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20251013205340.png)\n\n在Native层中，可以看到注册的函数，遵循静态注册的命名规则\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20251013205456.png)\n\n‍\n\n## 动态注册\n\n在本地库加载时（通常在 `JNI_OnLoad()`），或者在运行时由 C/C++ 代码主动调用 `RegisterNatives()`，把一组 `Java 方法名 + 方法签名 + 本地函数指针` 映射注册到 JVM，从而让 Java 代码调用这些本地实现。  \n它**不依赖**函数名的固定命名规则（`Java_package_Class_method`）手动把Java方法和C函数的对应关系注册到JVM\n\n​`JNI_OnLoad(JavaVM* vm, void* reserved)` 在 native-lib 被 `System.loadLibrary()` 时调用\n\n### 例子\n\n```java\npackage com.example;\n\npublic class MyClass {\n    static {\n        System.loadLibrary(\"native-lib\");\n    }\n\n    // Java 声明（实例方法）\n    public native void sayHello();\n    public native int add(int a, int b);\n    public static native String staticEcho(String s);\n}\n\n```\n\n```C\n// file: native_reg.c\n#include <jni.h>\n#include <stdio.h>\n#include <string.h>\n\n// 如果是 C++ 编译器，防止函数名被 mangling\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// -------------------- 本地实现函数 --------------------\n// 实例方法（对应 Java 的非 static native 方法）\nstatic void native_sayHello(JNIEnv* env, jobject thiz) {\n    // 简单打印 —— 注意：Android 上用 printf 可能看不到，建议用 __android_log_print\n    printf(\"native_sayHello invoked\\n\");\n}\n\n// 实例方法：带返回值与参数\nstatic jint native_add(JNIEnv* env, jobject thiz, jint a, jint b) {\n    return a + b;\n}\n\n// 静态方法（对应 Java 的 static native 方法）注意第二个参数类型是 jclass\nstatic jstring native_staticEcho(JNIEnv* env, jclass clazz, jstring js) {\n    const char* s = (*env)->GetStringUTFChars(env, js, NULL);\n    if (s == NULL) { // OOM or other error\n        return NULL;\n    }\n    // 这里可以处理字符串，演示直接返回一个新字符串\n    jstring ret = (*env)->NewStringUTF(env, s);\n    (*env)->ReleaseStringUTFChars(env, js, s);\n    return ret;\n}\n\n// -------------------- 方法表：Java 名称、签名、C 函数指针 --------------------\nstatic JNINativeMethod methods[] = {\n    // { \"Java 方法名\", \"JNI 签名\", (void*)本地函数指针 }\n    {\"sayHello\", \"()V\", (void*)native_sayHello},\n    {\"add\", \"(II)I\", (void*)native_add},\n    {\"staticEcho\", \"(Ljava/lang/String;)Ljava/lang/String;\", (void*)native_staticEcho}\n};\n\n// 辅助：计算方法表大小\nstatic const int methods_count = sizeof(methods) / sizeof(methods[0]);\n\n// -------------------- 注册函数（封装 RegisterNatives） --------------------\nstatic int register_native_methods(JNIEnv* env) {\n    // 注意：这里的类路径使用斜杠，不使用点号\n    const char* kClassPathName = \"com/example/MyClass\";\n    jclass clazz = (*env)->FindClass(env, kClassPathName);\n    if (clazz == NULL) {\n        // 如果 FindClass 失败，打印并清理异常（如果有）\n        if ((*env)->ExceptionCheck(env)) {\n            (*env)->ExceptionDescribe(env);\n            (*env)->ExceptionClear(env);\n        }\n        return JNI_FALSE;\n    }\n\n    // RegisterNatives 返回 < 0 表示失败\n    if ((*env)->RegisterNatives(env, clazz, methods, methods_count) < 0) {\n        if ((*env)->ExceptionCheck(env)) {\n            (*env)->ExceptionDescribe(env);\n            (*env)->ExceptionClear(env);\n        }\n        return JNI_FALSE;\n    }\n\n    // 如果你需要长期引用这个 jclass，应该创建全局引用：\n    // jclass globalClazz = (*env)->NewGlobalRef(env, clazz);\n    // 然后存储 globalClazz 供以后使用，并在卸载时 DeleteGlobalRef。\n    return JNI_TRUE;\n}\n\n// -------------------- JNI_OnLoad：库被 System.loadLibrary 时 JVM 调用 --------------------\nJNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved) {\n    JNIEnv* env = NULL;\n\n    // 获取 JNIEnv 指针 —— 注意线程安全与返回值检查\n    if ((*vm)->GetEnv(vm, (void**)&env, JNI_VERSION_1_6) != JNI_OK) {\n        return JNI_ERR; // 表示加载失败\n    }\n\n    // 注册 native 方法（通常在这里做，但 Android 情况见后文）\n    if (!register_native_methods(env)) {\n        return JNI_ERR; // 注册失败，返回错误使加载失败\n    }\n\n    // 返回所支持的 JNI 版本\n    return JNI_VERSION_1_6;\n}\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n\n```\n\n注意，这里的register_native_methods并不是必须要写的，它的作用只是让代码结构更清晰\n\n一个典型的辅助函数\n\n```C\nstatic int register_native_methods(JNIEnv* env, const char* className, JNINativeMethod* methods, int numMethods) {\n    jclass clazz = (*env)->FindClass(env, className);\n    if (clazz == NULL) {\n        return JNI_FALSE;\n    }\n    if ((*env)->RegisterNatives(env, clazz, methods, numMethods) < 0) {\n        return JNI_FALSE;\n    }\n    return JNI_TRUE;\n}\n\n```\n\n而Jni_Onload是必须的\n\n在Java层执行system.loadLibrary的时候被Jvm自动调用，当 native 库被加载时，完成初始化，比如注册 native 函数。\n\nJNI\\_OnLoad的标准写法\n\n```C\nJNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved)\n{\n    JNIEnv* env = NULL;\n\n    // 1. 获取 JNIEnv 指针\n    if ((*vm)->GetEnv(vm, (void**)&env, JNI_VERSION_1_6) != JNI_OK) {\n        return JNI_ERR;\n    }\n\n    // 2. 调用自己写的注册函数（可选）\n    if (!register_native_methods(env, \"com/example/MyClass\", methods, sizeof(methods) / sizeof(methods[0]))) {\n        return JNI_ERR;\n    }\n\n    // 3. 返回 JNI 版本号（必须）\n    return JNI_VERSION_1_6;\n}\n\n```\n\n在动态注册中，核心函数是\n\n```C\njint RegisterNatives(JNIEnv* env, jclass clazz, const JNINativeMethod* methods, jint nMethods);\n```\n\n注意，这个methods参数，是一个数组，类型为\n\n```C\ntypedef struct {\n    const char* name;       // Java 方法名\n    const char* signature;  // Java 方法签名（描述参数与返回值类型）\n    void* fnPtr;            // 对应的 C 函数指针\n} JNINativeMethod;\n```\n\n如果不传这个表，RegisterNatives()就不知道在注册什么东西\n\n所以也就是说，从逻辑上来看，方法表是一个必须的东西\n\n方法表的结构如下\n\n```C\nstatic JNINativeMethod methods[] = {\n    {\"sayHello\", \"()V\", (void*)native_sayHello},\n    {\"add\", \"(II)I\", (void*)native_add}\n};\n```\n\n\"sayHello\"这个字段表示函数名\n\n\"()V\"这个字段表示void\n\n(void*)native_sayHello字段表示函数地址\n\n第二个字段的常见签名方法如下\n\nJava 类型 -\\> JNI 签名\n\n- ​`void` -\\> `V`​\n- ​`boolean` -\\> `Z`​\n- ​`byte` -\\> `B`​\n- ​`char` -\\> `C`​\n- ​`short` -\\> `S`​\n- ​`int` -\\> `I`​\n- ​`long` -\\> `J`​\n- ​`float` -\\> `F`​\n- ​`double` -\\> `D`​\n- ​`Object` -\\> `Lfull/package/ClassName;` （包名用 `/`，例如 `Ljava/lang/String;`）\n- ​`int[]` -\\> `[I`、`String[]` -\\> `[Ljava/lang/String;`​\n\n举例：\n\n- ​`void foo()` -\\> `()V`​\n- ​`int sum(int a, int b)` -\\> `(II)I`​\n- ​`String process(String s, int[] arr)` -\\> `(Ljava/lang/String;[I)Ljava/lang/String;`​\n\n‍\n\n### 逆向\n\n同样可以看到注册了个native函数\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20251013213415.png)\n\n到了native层，可以发现大不同了\n\n首先可以看到JNI_Onload函数，看不到静态注册格式命名的函数名了\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20251013214105.png)\n\n那么应该怎样看动态注册了哪些函数呢\n\n还记得吗，在源码中，我们是写了一个“函数表”的\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20251013214246.png)\n\n在IDA中，如果没去符号表，是可以看到的\n\n我们点进去，就可以看到动态注册了哪些函数了\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20251013214313.png)\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20251013214347.png)\n\n‍\n","tags":["移动安全"],"categories":["逆向"]},{"title":"360加固保免费版分析","url":"/2025/07/25/360加固保免费版/","content":"\n分析360加固保免费版，学习逆向技术（此篇未完结）\n\n<!--more-->\n\n使用360加固保免费版加固，注意加固时要把签名校验给去除，因为加固之后的app是没有签名的，自己签名之后如果有签名校验，程序可能会闪退\n\n‍\n\n## Java层分析\n\n这是我自己写的一个app，可以看到没有加固时可以直接看到MainActivity\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709153602-4evta90.png)\n\n加固之后MainActivity字样没了，出现了StubAPP类和tianyu.util字样，可以知道这就是该加固的特征\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709153635-jfl8eqm.png)\n\nStubApp类里面使用a方法传递了一串字符串，跟进a方法，注意a有多个重载方法，需要查看具有一个字符串参数的重载方法\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709153810-asonqbd.png)\n\n发现就是对字符串进行一个解混淆，方式为异或16，这里可以用Cyberchef先解一下看看\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709153944-uz9a4kn.png)\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709154014-t5t5958.png)\n\n使用Frida hook看看这个方法做了些什么，直接在jadx里选择复制为frida片段\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709154239-eelvct9.png)\n\n```js\nfunction hook() {\n\n\n    let a = Java.use(\"com.tianyu.util.a\");\n    a[\"a\"].overload('java.lang.String').implementation = function (str) {\n        console.log(`a.a is called: str=${str}`);\n        let result = this[\"a\"](str);\n        console.log(`a.a result=${result}`);\n        return result;\n    };\n\n}\n\nfunction main() {\n\n    Java.perform(function () {\n        hook();\n    })\n}\n```\n\n可以看到就是加载了一些Android系统内部类或方法名\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709154306-w7jr6xk.png)\n\n继续观察StubApp类，看见下面会根据设备的架构来加载不同的so文件\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709155119-s00uw2u.png)\n\n再与正常未加固的apk对比一下，发现加固之后的apk多了一个assets文件夹，里面存着一些so文件\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709155941-sxtt2uw.png)\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709155958-xxqst5f.png)\n\n不难分析出，该加固是在Native层来释放dex文件\n\n‍\n\n## Native层分析\n\n分析so文件，发现导入导出表被抹除得一干二净\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709160226-czuhur7.png)\n\n如果没有导入导出表的话，elf文件应该是使用了自定义的动态链接器来进行链接的，所以，只要再elf文件被装载进内存之后将它dump下来，应该就能恢复符号表了\n\n在Linux系统中，dlopen函数用于动态链接库加载函数，它存在于`libdl.so`库中\n\n```C\n// 1. 加载库\nvoid* libHandle = dlopen(\"/data/data/pkg/libnative.so\", RTLD_NOW);\nif (!libHandle) {\n    printf(\"Error: %s\\n\", dlerror());\n    return;\n}\n\n// 2. 获取函数指针\ntypedef int (*NativeFunc)(int);\nNativeFunc func = (NativeFunc)dlsym(libHandle, \"native_add\");\nif (!func) {\n    printf(\"Error: %s\\n\", dlerror());\n    dlclose(libHandle);\n    return;\n}\n\n// 3. 调用函数\nint result = func(42);\n\n// 4. 卸载库\ndlclose(libHandle);\n```\n\n在安卓7.0之后，则需要hook的是android_dlopen_ext函数\n\nfrida hook一下看看它加载了哪些函数\n\nandroid_dlopen_ext() 的格式为`android_dlopen_ext(\"/data/data/pkg/libsecret.so\", RTLD_NOW, NULL);`，所以我们需要获取第一个参数的值来得到它链接了哪些so文件\n\n```C\nfunction hook() {\n\n    Interceptor.attach(Module.findExportByName(\"libdl.so\", \"android_dlopen_ext\"), {\n        onEnter: function (args) {\n            // console.log('Entering ' + functionName);\n            // Modify or log arguments if needed\n            console.log(\"load -> \", args[0].readCString());\n        },\n        onLeave: function (retval) {\n            // console.log('Leaving ' + functionName);\n            // Modify or log return value if needed\n        }\n    });\n}\n\nfunction main() {\n\n    Java.perform(function () {\n        hook();\n    })\n}\n\nsetImmediate(main);\n```\n\n正如所料，它链接了这个so文件\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709163334-dxuld2c.png)\n\n接下来在它将该so文件装载到内存之后dump下来，就可以得到带有导入导出表的so文件了\n\n（dump脚本来自SWDD）\n\n```js\nfunction dump_so() {\n    var soName = \"libjiagu_64.so\";\n    var libSo = Process.getModuleByName(soName);\n    var save_path = \"/data/data/com.example.nativetest/\" + libSo.name + \"_Dump\";\n    console.log(\"[Base]->\", libSo.base);\n    console.log(\"[Size]->\", ptr(libSo.size));\n    var handle = new File(save_path, \"wb\");\n    Memory.protect(ptr(libSo.base), libSo.size, 'rwx');\n    var Buffer = libSo.base.readByteArray(libSo.size);\n    handle.write(Buffer);\n    handle.flush();\n    handle.close();\n    console.log(\"[DumpPath->]\", save_path);\n\n}\n\nsetImmediate(dump_so);\n```\n\n注意，要在app运行之后再把脚本附加上去，否则如果还没来得及链接就dump的话，frida会直接报错\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709163731-zkjq895.png)\n\n所以这里使用命令\n\n```js\nfrida -U 'NativeTest' -l dump_so.js\n```\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709163808-0cfeau3.png)\n\n成功dump，并且得到了文件的基地址和大小\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709163918-56u3gz5.png)\n\n成功恢复\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709164129-v3p5sc3.png)\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709164143-2l9gqse.png)\n\n‍\n\n## 壳文件分析\n\n这里有一个知识点\n\n> ### **加固壳的典型行为模式**\n>\n> 加固壳的核心任务是 **保护原始代码**，其常见流程包括：\n>\n> 1. **解密资源**：\n>\n>     - 原始 APK/Dex/So 文件被加密，隐藏在 `assets`、`lib/` 或自定义目录中。\n>     - 运行时，壳代码需要先 **读取这些加密文件**（通过 `open` + `read`）。\n> 2. **动态加载**：\n>\n>     - 解密后的文件（如 Dex、So）会通过 `dlopen`、`mmap` 或 `DexClassLoader` 加载到内存。\n> 3. **内存执行**：\n>\n>     - 解密后的代码在内存中执行，避免留下完整的磁盘文件。\n>\n> **关键点**：  \n> ➜ **加固壳必须读取加密文件** → 必然调用 `open` 函数 → **Hook** **​`open`​** **可以捕获文件访问路径**。\n\n思路就是 hook open函数来看看它有没有读取什么东西\n\n```js\nfunction hook() {\n\n    var openPtr = Module.findExportByName(null, \"open\");\n    // var openAdrr = new NativePointer(openPtr);\n    const open = new NativeFunction(openPtr, 'int', ['pointer', 'int']);\n\n    Interceptor.replace(openPtr, new NativeCallback(function (fileNamePtr, flag) {\n        \n        var fileName = fileNamePtr.readCString();\n        console.log(\"[open : ]\", fileName);\n\n        return open(fileNamePtr, flag);\n    } , 'int', ['pointer', 'int']))\n\n\n}\n\nfunction main() {\n\n    Java.perform(function () {\n        hook();\n    })\n}\n\n// setTimeout(main, 1000);\nsetImmediate(main);\n```\n\n注意这里一定要new一个NativeCallback\n\n在 Frida 中，`NativeCallback` 的作用是 **创建一个符合原生代码调用约定的 JavaScript 回调函数**，用于替换或拦截原生函数（如 `open`）\n\n原生代码（如 C 的 `open` 函数）有严格的 **参数传递规则**（如寄存器/栈传参、类型转换），而 JavaScript 是弱类型语言，无法直接匹配\n\n不然的话会出现如下报错\n\n`fileNamePtr` 可能未被正确识别为 `pointer` 类型\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709215005-d6hgc81.png)\n\n可以看到打开了如下文件\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/image-20250709215238-5ec1xgp.png)\n\n发现个很可疑的点，它频繁访问了 /proc/self/maps\n\n> ###   **​`/proc/self/maps`​** **的作用**\n>\n> - **功能**：该文件实时显示当前进程的内存映射布局，包括：\n>\n>   - 加载的模块（`.so`/`.dex`）基地址和大小\n>   - 内存权限（可读/可写/可执行）\n>   - 文件来源路径\n> - **典型访问场景**：\n>\n>   - **加固壳**：检测内存是否被篡改（反调试）。\n>   - **动态加载库**：定位空闲内存区域加载新代码。\n>   - **内存扫描**：查找敏感数据或函数地址。\n\n这里反复读取maps猜测是为了混淆视听，当加载dex时，maps上的内存映射会发生变化，留下记录，比如 /data/app/xxx/base.dex，这时候壳文件就通过反复读取maps来隐藏打开dex的操作，掩盖真正的 Dex 加载时机\n\n此时，如果我们自定义一个fakeMaps，将壳文件对maps的操作重定向到我们的fakeMaps上，就可以很方便地观察壳文件加载dex的操作了，同时也能避免壳的反检测机制（如果有的话）\n\n```js\nfunction hook() {\n\n    var openPtr = Module.findExportByName(null, \"open\");\n    // var openAdrr = new NativePointer(openPtr);\n    const open = new NativeFunction(openPtr, 'int', ['pointer', 'int']);\n\n    var fakeMaps = \"/data/data/com.example.nativetest/maps\"\n\n    Interceptor.replace(openPtr, new NativeCallback(function (fileNamePtr, flag) {\n\n        var fileName = fileNamePtr.readCString();\n        console.log(\"[open : ]\", fileName);\n\n        var FD = open(fileNamePtr, flag); //调用原始open函数，记录原始open函数的文件描述符\n\n        if (fileName.indexOf(\"maps\") >= 0) {  //如果文件名包含maps，将其重定向到fakeMaps上\n            \n            console.log(\"sucess find maps\");\n\n            var fakeMapsAddr = Memory.allocUtf8String(fakeMaps);\n            return open(fakeMapsAddr, flag); // 打开伪造的maps文件，并返回其文件描述符（FD），而非真实的maps\n            \n        }\n\n        if (fileName.indexOf(\"dex\" != -1)) {\n            console.warn(\"open dex :\", fileName);\n        }\n\n        return FD; //返回原始FD使app正常运行\n        // return open(fileNamePtr, flag);\n    }, 'int', ['pointer', 'int']))\n\n\n}\n\nfunction main() {\n\n    Java.perform(function () {\n        hook();\n    })\n}\n\n// setTimeout(main, 1000);\nsetImmediate(main);\n\n```\n\n可以发现确实是通过open去打开了dex文件，而且通过反复读取了maps来隐藏操作，验证了我们之前的猜想\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250715203358.png)\n\n使用来查看dex的内存地址\n\n```js\nconsole.warn('dex called from:\\n' + Thread.backtrace(this.context, Backtracer.FUZZY).map(DebugSymbol.fromAddress).join('\\n') + '\\n');\n```\n\n```js\nfunction hook() {\n\n    var openPtr = Module.findExportByName(null, \"open\");\n    // var openAdrr = new NativePointer(openPtr);\n    const open = new NativeFunction(openPtr, 'int', ['pointer', 'int']);\n    var fakeMaps = \"/data/data/com.example.nativetest/maps\";\n\n    Interceptor.replace(openPtr, new NativeCallback(function (fileNamePtr, flag) {\n\n        var fileName = fileNamePtr.readCString();\n        console.log(\"[open : ]\", fileName);\n        var FD = open(fileNamePtr, flag); //调用原始open函数，记录原始open函数的文件描述符\n\n        if (fileName.indexOf(\"maps\") >= 0) {  //如果文件名包含maps，将其重定向到fakeMaps上\n            \n            console.log(\"sucess find maps\");\n            var fakeMapsAddr = Memory.allocUtf8String(fakeMaps);\n            return open(fakeMapsAddr, flag); // 打开伪造的maps文件，并返回其文件描述符（FD），而非真实的maps\n            \n        }\n\n        if (fileName.indexOf(\"dex\") != -1) {\n            console.warn(\"open dex :\", fileName);\n            console.warn('dex called from:\\n' + Thread.backtrace(this.context, Backtracer.FUZZY).map(DebugSymbol.fromAddress).join('\\n') + '\\n');\n            \n        }\n\n        return FD; //返回原始FD使app正常运行\n        // return open(fileNamePtr, flag);\n    }, 'int', ['pointer', 'int']))\n\n\n}\n\nfunction main() {\n\n    Java.perform(function () {\n        hook();\n    })\n}\n\n// setTimeout(main, 1000);+\nsetImmediate(main);\n```\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250715205613.png)\n\n可以发现打开dex的地址基本一模一样，在IDA中查看这个地址\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250715205949.png)\n\n嘶，啥也没有，这不对吧\n\n查阅多方资料，发现我漏了一步，在先前dump so文件的时候，so文件可能会有损坏，所以先需要修复一下so文件\n\n使用soFixer\n\n[soFixer](https://github.com/F8LEFT/SoFixer)   0x0x7fff56d99000是之前dump so文件的时候输出的基地址\n\n```js\n.\\SoFixer-Windows-64.exe -s .\\libjiagu_64.so_Dump -o .\\libjiagu_64.so_Fix -m 0x7fff56d99000 -d\n```\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250715210744.png)\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250715210721.png)\n\n使用sofix之后IDA将其识别成了ARM架构，但是我原本的文件是x86_64架构，这里要重新选择一下\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250715211520.png)\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250715211720.png)\n\n这下就没问题了\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250715212218.png)\n\n但是这段数据全是未定义的，这个时候就手足无措了\n\n一通乱翻，发现了这样一个函数\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250715220229.png)\n\n```C\nchar __fastcall __arm_a_2(char *a1, unsigned __int64 a2, char *a3, int *a4, unsigned int a5)\n{\n  unsigned __int64 v5; // rax\n  __int64 *v6; // rsi\n  __int64 v7; // rbx\n  __int64 *v8; // rdi\n  __int64 v9; // rax\n  _QWORD *v10; // rbx\n  char v12[8]; // [rsp+90h] [rbp-168h] BYREF\n  unsigned __int64 v13; // [rsp+98h] [rbp-160h]\n  __int64 v14; // [rsp+A0h] [rbp-158h]\n  __int64 v15[7]; // [rsp+B0h] [rbp-148h] BYREF\n  _QWORD v16[2]; // [rsp+E8h] [rbp-110h] BYREF\n  __int128 v17; // [rsp+F8h] [rbp-100h]\n  __int128 v18[8]; // [rsp+108h] [rbp-F0h] BYREF\n  __int128 v19; // [rsp+188h] [rbp-70h]\n  __int128 v20; // [rsp+198h] [rbp-60h]\n  __int128 v21[2]; // [rsp+1A8h] [rbp-50h] BYREF\n  int *v22; // [rsp+1D0h] [rbp-28h]\n  unsigned __int64 v23; // [rsp+1D8h] [rbp-20h]\n  unsigned __int64 v24; // [rsp+1E8h] [rbp-10h]\n\n  v24 = __readfsqword(0x28u);\n  v23 = a5;\n  v22 = a4;\n  sub_2DA0();\n  v5 = __readfsqword(0x28u);\n  if ( v5 != v24 )\n  {\n    sub_2D40(qword_1C928, 0x190LL);\n    v23 = a1;\n    v22 = __readfsqword(0x28u);\n    memset(v21, 0, sizeof(v21));\n    v20 = 0LL;\n    v19 = 0LL;\n    memset(v18, 0, sizeof(v18));\n    v17 = 0LL;\n    sub_2D20(v18 + 4, \"*.so\", 0x80LL, 0xBCLL, 5LL);\n    v16[0] = &qword_234D0;\n    v16[1] = 0xAC3FDLL;\n    LODWORD(v18[0]) = 1;\n    *&v20 = off_233B8;\n    *(&v19 + 1) = &qword_CFD40;\n    DWORD2(v21[1]) = 1;\n    *(&v20 + 1) = 0x400000002LL;\n    LODWORD(v21[0]) = 5;\n    *(v21 + 8) = 0LL;\n    sub_7330(v15);\n    v15[0] = qword_22CA8 + 16;\n    v6 = &qword_CF8D0;\n    if ( sub_7770(v15, &qword_CF8D0, 1062LL) )\n    {\n      v6 = v15;\n      v7 = sub_5C10(v16, v15);\n      if ( *(&v21[0] + 1) )\n        (sub_2EE0)();\n    }\n    else\n    {\n      v7 = 0LL;\n    }\n    v8 = v15;\n    sub_7580(v15);\n    if ( __readfsqword(0x28u) == v22 )\n    {\n      LOBYTE(v5) = v7;\n    }\n    else\n    {\n      sub_2D40(v15, v6);\n      v14 = v7;\n      v13 = __readfsqword(0x28u);\n      if ( v15 )\n      {\n        strcpy(v12, \"makekey\");\n        v6 = v12;\n        v9 = sub_5D40(v15, v12);\n        if ( v9 )\n        {\n          v10 = v9;\n          v8 = (v9 & 0xFFFFFFFFFFFFF000LL);\n          v6 = (\"pthread_create\" + 3);\n          sub_2E50(v9 & 0xFFFFFFFFFFFFF000LL, 4096LL, 3LL);\n          *v10 = qword_22CC0;\n        }\n      }\n      v5 = __readfsqword(0x28u);\n      if ( v5 != v13 )\n      {\n        sub_2D40(v8, v6);\n        LOBYTE(v5) = 1;\n      }\n    }\n  }\n  return v5;\n}\n```\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250715220849.png)\n\n查看sub_50E0\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250715220917.png)\n\n发现了一些用于加载动态链接相关的字符串，结合之前创建线程，这个时候就猜测，应该已经在加载另外的so了\n\n‍\n\n安卓系统中，完成linker之后，dlopen去加载这个so，我们之前hook的是`android_dlopen_ext`，这里再去hook一下dlopen看看它加载了哪些so文件\n\n```js\nfunction hook() {\n\n    Interceptor.attach(Module.findExportByName(\"libdl.so\", \"android_dlopen_ext\"), {\n        onEnter: function (args) {\n            // console.log('Entering ' + functionName);\n            // Modify or log arguments if needed\n            console.log(\"load -> \", args[0].readCString());\n        },\n        onLeave: function (retval) {\n            // console.log('Leaving ' + functionName);\n            // Modify or log return value if needed\n        }\n    });\n\n}\n\nfunction hook2() {\n    \n    Interceptor.attach(Module.findExportByName(\"libdl.so\", \"dlopen\"), {\n        onEnter: function (args) {\n            // console.log('Entering ' + functionName);\n            // Modify or log arguments if needed\n            console.warn(\"dlopen load -> \", args[0].readCString());\n        },\n        onLeave: function (retval) {\n            // console.log('Leaving ' + functionName);\n            // Modify or log return value if needed\n        }\n    });\n}\n\nfunction main() {\n\n    Java.perform(function () {\n        hook();\n        hook2();\n    })\n}\n\n// setTimeout(main, 1000);\nsetImmediate(main);\n```\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716105833.png)\n\n看到这里，基本上可以说明就是自定义linker加固so文件了\n\n‍\n\n查阅资料发现，自定义linker加固so的流程是，自定义文件格式加密so，然后壳代码实现将加密的so文件加载，链接重定位并修正soinfo（三部曲）\n\n简单来说就是将elf文件的.text等数据段进行加密，然后在link的时候补充soinfo\n\n> `soinfo` 是 **Android linker** 内部维护的数据结构，用于 **管理已加载的共享库（.so）** 。每个被 `dlopen` 或程序依赖的 `.so` 都会有一个对应的 `soinfo` 结构，存储：\n>\n> - **库的基地址（加载地址）**\n> - **符号表、重定位表、依赖关系**\n> - **动态段（**​ **​`.dynamic`​**​ **）解析后的信息**\n> - **命名空间（用于库隔离）**\n> - ### **​`soinfo`​** **的生命周期**\n>\n>   1. **加载阶段**：`dlopen` → `linker` 解析 ELF → 创建 `soinfo` 并填充信息。\n>   2. **链接阶段**：`linker` 根据 `.dynamic` 段解析依赖、符号、重定位。\n>   3. **运行时**：`dlsym` 通过 `soinfo` 查找符号地址。\n>   4. **卸载阶段**：`dlclose` 释放 `soinfo`。\n\n由于之前的so在执行的时候link了另外的so，所以将其放入010editor里查找elf头\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716112140.png)\n\n找到了elf头，并且可以看到program header已经被加密了\n\n写一个脚本，将0xd0000之后的内容提取出来\n\n提取出来的so文件ida是打不开的，因为program header已经被加密了\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716113145.png)\n\n此时就需要找到这个so是在哪里被解密的\n\n用oacia大佬的项目来分析一下程序执行流\n\n[https://github.com/oacia/stalker_trace_so](https://github.com/oacia/stalker_trace_so)\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716114648.png)\n\n```js\n[Android Emulator 5554::com.example.nativetest ]-> start Stalker!\nStalker end!\ncall1:JNI_OnLoad\ncall2:sub_C840\ncall3:ffi_call\ncall4:sub_C450\ncall5:sub_7330\ncall6:sub_7770\ncall7:sub_7370\ncall8:_ZN9__arm_c_19__arm_c_0Ev\ncall9:sub_77B0\ncall10:sub_71F0\ncall11:sub_C560\ncall12:sub_7240\ncall13:sub_42C0\ncall14:sub_6310\ncall15:sub_6A30\ncall16:sub_6760\ncall17:sub_4B40\ncall18:sub_4F70\ncall19:sub_50E0\ncall20:sub_3B20\ncall21:sub_7000\ncall22:sub_6350\ncall23:sub_7580\ncall24:sub_10E1D0\ncall25:sub_1BC3C0\ncall26:sub_10B270\ncall27:sub_1465C0\ncall28:sub_14AC90\ncall29:sub_10A5C0\ncall30:sub_1BDD20\ncall31:sub_14B3E0\ncall32:sub_14D100\ncall33:sub_1BDD50\ncall34:sub_1A9BD0\ncall35:sub_1459B0\ncall36:sub_1BD700\ncall37:sub_1BD790\ncall38:sub_10ED90\ncall39:sub_1120F0\ncall40:sub_10CC10\ncall41:sub_106F90\ncall42:sub_1BB530\ncall43:sub_1BB620\ncall44:sub_1BC4E0\ncall45:sub_1BB980\ncall46:sub_1BBC00\ncall47:sub_1BBE10\ncall48:sub_1BC1D0\ncall49:sub_1BC4B0\ncall55:sub_1BDF10\ncall56:sub_116720\ncall57:sub_1BDD00\ncall58:sub_1AD9E0\ncall59:sub_1ADB60\ncall60:sub_1C49A0\ncall61:sub_1CAD30\ncall62:sub_1C8EC0\ncall63:sub_16FA70\n```\n\n再看一下fix之后的文件的控制流\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716200634.png)\n\n```js\n[Android Emulator 5554::com.example.nativetest ]-> start Stalker!\ncall1:JNI_OnLoad\ncall2:sub_C840\ncall3:ffi_call\ncall4:sub_C450\ncall5:sub_7330\ncall6:sub_7770\ncall7:sub_7370\ncall8:_ZN9__arm_c_19__arm_c_0Ev\ncall9:sub_77B0\ncall10:sub_71F0\ncall11:sub_C560\ncall12:sub_7240\ncall13:sub_42C0\ncall14:sub_6310\ncall15:sub_6A30\ncall16:sub_6760\ncall17:sub_4B40\ncall18:sub_4F70\ncall19:sub_50E0\ncall20:sub_3B20\ncall21:sub_7000\ncall22:sub_6350\ncall23:sub_7580\ncall24:sub_10E1D0\ncall25:sub_1BC3C0\ncall26:sub_10B270\ncall27:sub_1465C0\ncall28:sub_14AC90\ncall29:sub_10A5C0\ncall30:sub_1BDD20\ncall31:sub_14B3E0\ncall32:sub_14D100\ncall33:sub_1BDD50\ncall34:sub_1A9BD0\ncall35:sub_1459B0\ncall36:sub_1BD700\ncall37:sub_1BD790\ncall38:sub_10ED90\ncall39:sub_1120F0\ncall40:sub_10CC10\ncall41:sub_106F90\ncall42:sub_1BB530\ncall43:sub_1BB620\ncall44:sub_1BC4E0\ncall45:sub_1BB980\ncall46:sub_1BBC00\ncall47:sub_1BBE10\ncall48:sub_1BC1D0\ncall49:sub_1BC4B0\ncall50:sub_14B000\ncall51:sub_14D310\ncall52:_Z9__arm_a_2PcmS_Rii\ncall53:sub_14ACC0\ncall54:sub_10C5F0\ncall55:sub_1BDF10\ncall56:sub_116720\ncall57:sub_1BDD00\ncall58:sub_1AD9E0\ncall59:sub_1ADB60\ncall60:sub_1C49A0\ncall61:sub_1CAD30\ncall62:sub_1C8EC0\ncall63:sub_16FA70\n```\n\n‍\n\n‍\n\n知道了控制流之后，虽然是自定义linker加固so，但是最后肯定还是需要dlopen去加载so的，在IDA里交叉引用一下dlopen，看看在哪里被调用了\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716115942.png)\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716120042.png)\n\n只有一处调用，全是switch case结构\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716120058.png)\n\n查看Android源码linker的预链接部分，同样也是大量的switch case结构\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716160821.png)\n\n此时就可以在IDA中导入soinfo结构体了（结构体代码来自SWDD）\n\n```js\n//IMPORTANT\n//ELF64 启用该宏\n#define __LP64__  1\n//ELF32 启用该宏\n//#define __work_around_b_24465209__  1\n \n/*\n//https://android.googlesource.com/platform/bionic/+/master/linker/Android.bp\n架构为 32 位 定义__work_around_b_24465209__宏\narch: {\n        arm: {cflags: [\"-D__work_around_b_24465209__\"],},\n        x86: {cflags: [\"-D__work_around_b_24465209__\"],},\n    }\n*/\n \n//android-platform\\bionic\\libc\\include\\link.h\n#if defined(__LP64__)\n#define ElfW(type) Elf64_ ## type\n#else\n#define ElfW(type) Elf32_ ## type\n#endif\n \n//android-platform\\bionic\\linker\\linker_common_types.h\n// Android uses RELA for LP64.\n#if defined(__LP64__)\n#define USE_RELA 1\n#endif\n \n//android-platform\\bionic\\libc\\kernel\\uapi\\asm-generic\\int-ll64.h\n//__signed__-->signed\ntypedef signed char __s8;\ntypedef unsigned char __u8;\ntypedef signed short __s16;\ntypedef unsigned short __u16;\ntypedef signed int __s32;\ntypedef unsigned int __u32;\ntypedef signed long long __s64;\ntypedef unsigned long long __u64;\n \n//A12-src\\msm-google\\include\\uapi\\linux\\elf.h\n/* 32-bit ELF base types. */\ntypedef __u32   Elf32_Addr;\ntypedef __u16   Elf32_Half;\ntypedef __u32   Elf32_Off;\ntypedef __s32   Elf32_Sword;\ntypedef __u32   Elf32_Word;\n \n/* 64-bit ELF base types. */\ntypedef __u64   Elf64_Addr;\ntypedef __u16   Elf64_Half;\ntypedef __s16   Elf64_SHalf;\ntypedef __u64   Elf64_Off;\ntypedef __s32   Elf64_Sword;\ntypedef __u32   Elf64_Word;\ntypedef __u64   Elf64_Xword;\ntypedef __s64   Elf64_Sxword;\n \ntypedef struct dynamic{\n  Elf32_Sword d_tag;\n  union{\n    Elf32_Sword d_val;\n    Elf32_Addr  d_ptr;\n  } d_un;\n} Elf32_Dyn;\n \ntypedef struct {\n  Elf64_Sxword d_tag;       /* entry tag value */\n  union {\n    Elf64_Xword d_val;\n    Elf64_Addr d_ptr;\n  } d_un;\n} Elf64_Dyn;\n \ntypedef struct elf32_rel {\n  Elf32_Addr    r_offset;\n  Elf32_Word    r_info;\n} Elf32_Rel;\n \ntypedef struct elf64_rel {\n  Elf64_Addr r_offset;  /* Location at which to apply the action */\n  Elf64_Xword r_info;   /* index and type of relocation */\n} Elf64_Rel;\n \ntypedef struct elf32_rela{\n  Elf32_Addr    r_offset;\n  Elf32_Word    r_info;\n  Elf32_Sword   r_addend;\n} Elf32_Rela;\n \ntypedef struct elf64_rela {\n  Elf64_Addr r_offset;  /* Location at which to apply the action */\n  Elf64_Xword r_info;   /* index and type of relocation */\n  Elf64_Sxword r_addend;    /* Constant addend used to compute value */\n} Elf64_Rela;\n \ntypedef struct elf32_sym{\n  Elf32_Word    st_name;\n  Elf32_Addr    st_value;\n  Elf32_Word    st_size;\n  unsigned char st_info;\n  unsigned char st_other;\n  Elf32_Half    st_shndx;\n} Elf32_Sym;\n \ntypedef struct elf64_sym {\n  Elf64_Word st_name;       /* Symbol name, index in string tbl */\n  unsigned char st_info;    /* Type and binding attributes */\n  unsigned char st_other;   /* No defined meaning, 0 */\n  Elf64_Half st_shndx;      /* Associated section index */\n  Elf64_Addr st_value;      /* Value of the symbol */\n  Elf64_Xword st_size;      /* Associated symbol size */\n} Elf64_Sym;\n \n#define EI_NIDENT   16\n \ntypedef struct elf32_hdr{\n  unsigned char e_ident[EI_NIDENT];\n  Elf32_Half    e_type;\n  Elf32_Half    e_machine;\n  Elf32_Word    e_version;\n  Elf32_Addr    e_entry;  /* Entry point */\n  Elf32_Off e_phoff;\n  Elf32_Off e_shoff;\n  Elf32_Word    e_flags;\n  Elf32_Half    e_ehsize;\n  Elf32_Half    e_phentsize;\n  Elf32_Half    e_phnum;\n  Elf32_Half    e_shentsize;\n  Elf32_Half    e_shnum;\n  Elf32_Half    e_shstrndx;\n} Elf32_Ehdr;\n \ntypedef struct elf64_hdr {\n  unsigned char e_ident[EI_NIDENT]; /* ELF \"magic number\" */\n  Elf64_Half e_type;\n  Elf64_Half e_machine;\n  Elf64_Word e_version;\n  Elf64_Addr e_entry;       /* Entry point virtual address */\n  Elf64_Off e_phoff;        /* Program header table file offset */\n  Elf64_Off e_shoff;        /* Section header table file offset */\n  Elf64_Word e_flags;\n  Elf64_Half e_ehsize;\n  Elf64_Half e_phentsize;\n  Elf64_Half e_phnum;\n  Elf64_Half e_shentsize;\n  Elf64_Half e_shnum;\n  Elf64_Half e_shstrndx;\n} Elf64_Ehdr;\n \n/* These constants define the permissions on sections in the program\n   header, p_flags. */\n#define PF_R        0x4\n#define PF_W        0x2\n#define PF_X        0x1\n \ntypedef struct elf32_phdr{\n  Elf32_Word    p_type;\n  Elf32_Off p_offset;\n  Elf32_Addr    p_vaddr;\n  Elf32_Addr    p_paddr;\n  Elf32_Word    p_filesz;\n  Elf32_Word    p_memsz;\n  Elf32_Word    p_flags;\n  Elf32_Word    p_align;\n} Elf32_Phdr;\n \ntypedef struct elf64_phdr {\n  Elf64_Word p_type;\n  Elf64_Word p_flags;\n  Elf64_Off p_offset;       /* Segment file offset */\n  Elf64_Addr p_vaddr;       /* Segment virtual address */\n  Elf64_Addr p_paddr;       /* Segment physical address */\n  Elf64_Xword p_filesz;     /* Segment size in file */\n  Elf64_Xword p_memsz;      /* Segment size in memory */\n  Elf64_Xword p_align;      /* Segment alignment, file & memory */\n} Elf64_Phdr;\n \ntypedef struct elf32_shdr {\n  Elf32_Word    sh_name;\n  Elf32_Word    sh_type;\n  Elf32_Word    sh_flags;\n  Elf32_Addr    sh_addr;\n  Elf32_Off sh_offset;\n  Elf32_Word    sh_size;\n  Elf32_Word    sh_link;\n  Elf32_Word    sh_info;\n  Elf32_Word    sh_addralign;\n  Elf32_Word    sh_entsize;\n} Elf32_Shdr;\n \ntypedef struct elf64_shdr {\n  Elf64_Word sh_name;       /* Section name, index in string tbl */\n  Elf64_Word sh_type;       /* Type of section */\n  Elf64_Xword sh_flags;     /* Miscellaneous section attributes */\n  Elf64_Addr sh_addr;       /* Section virtual addr at execution */\n  Elf64_Off sh_offset;      /* Section file offset */\n  Elf64_Xword sh_size;      /* Size of section in bytes */\n  Elf64_Word sh_link;       /* Index of another section */\n  Elf64_Word sh_info;       /* Additional section information */\n  Elf64_Xword sh_addralign; /* Section alignment */\n  Elf64_Xword sh_entsize;   /* Entry size if section holds table */\n} Elf64_Shdr;\n \n//android-platform\\bionic\\linker\\linker_soinfo.h\ntypedef void (*linker_dtor_function_t)();\ntypedef void (*linker_ctor_function_t)(int, char**, char**);\n \n#if defined(__work_around_b_24465209__)\n#define SOINFO_NAME_LEN 128\n#endif\n \nstruct soinfo {\n#if defined(__work_around_b_24465209__)\n  char old_name_[SOINFO_NAME_LEN];\n#endif\n  const ElfW(Phdr)* phdr;\n  size_t phnum;\n#if defined(__work_around_b_24465209__)\n  ElfW(Addr) unused0; // DO NOT USE, maintained for compatibility.\n#endif\n  ElfW(Addr) base;\n  size_t size;\n \n#if defined(__work_around_b_24465209__)\n  uint32_t unused1;  // DO NOT USE, maintained for compatibility.\n#endif\n \n  ElfW(Dyn)* dynamic;\n \n#if defined(__work_around_b_24465209__)\n  uint32_t unused2; // DO NOT USE, maintained for compatibility\n  uint32_t unused3; // DO NOT USE, maintained for compatibility\n#endif\n \n  soinfo* next;\n  uint32_t flags_;\n \n  const char* strtab_;\n  ElfW(Sym)* symtab_;\n \n  size_t nbucket_;\n  size_t nchain_;\n  uint32_t* bucket_;\n  uint32_t* chain_;\n \n#if !defined(__LP64__)\n  ElfW(Addr)** unused4; // DO NOT USE, maintained for compatibility\n#endif\n \n#if defined(USE_RELA)\n  ElfW(Rela)* plt_rela_;\n  size_t plt_rela_count_;\n \n  ElfW(Rela)* rela_;\n  size_t rela_count_;\n#else\n  ElfW(Rel)* plt_rel_;\n  size_t plt_rel_count_;\n \n  ElfW(Rel)* rel_;\n  size_t rel_count_;\n#endif\n \n  linker_ctor_function_t* preinit_array_;\n  size_t preinit_array_count_;\n \n  linker_ctor_function_t* init_array_;\n  size_t init_array_count_;\n  linker_dtor_function_t* fini_array_;\n  size_t fini_array_count_;\n \n  linker_ctor_function_t init_func_;\n  linker_dtor_function_t fini_func_;\n \n/*\n#if defined (__arm__)\n  // ARM EABI section used for stack unwinding.\n  uint32_t* ARM_exidx;\n  size_t ARM_exidx_count;\n#endif\n  size_t ref_count_;\n// 怎么找不 link_map 这个类型的声明...\n  link_map link_map_head;\n \n  bool constructors_called;\n \n  // When you read a virtual address from the ELF file, add this\n  //value to get the corresponding address in the process' address space.\n  ElfW (Addr) load_bias;\n \n#if !defined (__LP64__)\n  bool has_text_relocations;\n#endif\n  bool has_DT_SYMBOLIC;\n*/\n};\n```\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716161049.png)\n\n按Y将该函数类型改成so\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716161551.png)\n\n好看多了，但看着还是有点奇怪，可能这个soinfo被魔改过了\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716161625.png)\n\n交叉引用一下，来到上一个函数，有这样一个函数，我们点进去看看\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716161856.png)\n\n最终来到这个地方\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716162052.png)\n\n有一个很可疑的点是v5往上加了0x38\n\n![image](assets/image-20250716162637-7u4zl4e.png)\n\n在ELF文件中，32 位 ELF 文件程序头大小是 0x20（32 字节），64 位 ELF 文件程序头大小是 0x38（56 字节）\n\n这里正好就是0x38，所以这里可能就在加载程序头了。\n\n既然要加载程序头，那么在加载之前肯定需要解密，往上引用一下，最后又来到这里，有点眼熟\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716163100.png)\n\n还记得之前拿到的执行流么，从7000，即加载程序头的函数开始，往上找一找\n\n在50E0的位置发现这里加载了一些东西\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716201757.png)\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716201838.png)\n\n继续往上翻，在7240的位置填入了一个地址进去\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716210205.png)\n\n去那个地址看一眼，AUV，这不rc4么\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716210241.png)\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716210231.png)\n\n上面那个则是初始化算法\n\n![image](https://cdn.jsdelivr.net/gh/F10ower/img@main/img/20250716210313.png)\n\n直接hook出sbox\n\n‍\n","tags":["移动安全"],"categories":["逆向"]},{"title":"报任安书","url":"/2024/07/26/报任安书/","content":"\n然此可为智者道，难为俗人言也\n\n<!--more-->\n\n# 报任安书（节选）\n\n## 【两汉】司马迁\n\n古者富贵而名摩灭，不可胜记，唯倜傥非常之人称焉。盖文王拘而演《周易》；仲尼厄而作《春秋》；屈原放逐，乃赋《离骚》；左丘失明，厥有《国语》；孙子膑脚，《兵法》修列；不韦迁蜀，世传《吕览》；韩非囚秦，《说难》《孤愤》；《诗》三百篇，大底圣贤发愤之所为作也。此人皆意有所郁结，不得通其道，故述往事、思来者。乃如左丘无目，孙子断足，终不可用，退而论书策，以舒其愤，思垂空文以自见。\n\n　　仆窃不逊，近自托于无能之辞，网罗天下放失旧闻，略考其行事，综其终始，稽其成败兴坏之纪，上计轩辕，下至于兹，为十表，本纪十二，书八章，世家三十，列传七十，凡百三十篇。亦欲以究天人之际，通古今之变，成一家之言。草创未就，会遭此祸，惜其不成，是以就极刑而无愠色。仆诚以著此书，藏之名山，传之其人，通邑大都，则仆偿前辱之责，虽万被戮，岂有悔哉！然此可为智者道，难为俗人言也！\n","tags":["古代散文"],"categories":["古文"]},{"title":"[DASCTF2024夏季挑战赛]StrangePrograme","url":"/2024/07/25/DASCTF2024夏季挑战赛-StrangePrograme/","content":"眼前所见，亦非真实\n<!--more-->\n你看到的我并不是真正的我，你看到的memcmp不是真正的memcmp\n\n![image-20240725170939564](image-20240725170939564.png)\n\n为什么memcmp要保留它当memcmp函数的历史\n\n因为它是钩子\n\n\n\n.DASCTF段一大段爆红，首先想到smc\n\n![image-20240725171825345](image-20240725171825345.png)\n\n跟随IsDebuggerPresent()的脚步来到这个函数\n\n![image-20240725171845428](image-20240725171845428.png)\n\n找到smc的地方\n\n![image-20240725171906045](image-20240725171906045.png)\n\n下面是被加密的.DASCTF段\n\n![image-20240725171927351](image-20240725171927351.png)\n\n断点一打，开始调试\n\n.DASCTF段解密后恢复里面的几个关键函数\n\n这里，memcmp被hook了，它已经不是原来的memcmp了\n\n![image-20240725171947690](image-20240725171947690.png)\n\n这里是加密\n\n![image-20240725172013011](image-20240725172013011.png)\n\nTEA\n\n![image-20240725172026696](image-20240725172026696.png)\n\n此时如果回主函数找到memcmp，一路跟进，会来到这个地方，这是动态链接库里的memcmp\n\n![image-20240725172046275](image-20240725172046275.png)\n\n> 总得来说，被hook的函数会改变它原本的功能，所以main函数里的memcmp并不是比较，而是加密\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid De_tea(unsigned int *a1, unsigned int *a2)\n{\n\n    unsigned int i; // [esp+DCh] [ebp-2Ch]\n    int v4;     // [esp+E8h] [ebp-20h]\n    unsigned int v5;    // [esp+F4h] [ebp-14h]\n    unsigned int v6;    // [esp+100h] [ebp-8h]\n\n    v6 = *a1;\n    v5 = a1[1];\n\n    // for (i = 0; i < 16; ++i)\n    // {\n    //     v6 += (a2[1] + (v5 >> 5)) ^ (v4 + v5) ^ (*a2 + 16 * v5);\n    //     v5 += (a2[3] + (v6 >> 5)) ^ (v4 + v6) ^ (a2[2] + 16 * v6);\n    //     v4 -= 1640531527;\n    // }\n    v4 = 0 - 16 * 0x61C88647;\n    for (i = 0; i < 16; ++i)\n    {\n        v4 += 0x61C88647;\n        v5 -= (a2[3] + (v6 >> 5)) ^ (v4 + v6) ^ (a2[2] + 16 * v6);\n        v6 -= (a2[1] + (v5 >> 5)) ^ (v4 + v5) ^ (*a2 + 16 * v5);\n        \n    }\n\n    *a1 = v6;\n    a1[1] = v5;\n}\n\nint main(){\n\n    __int64 v1;      // rax\n    __int64 v3;      // [esp-8h] [ebp-24Ch]\n    int j;           // [esp+D0h] [ebp-174h]\n    size_t i;        // [esp+F4h] [ebp-150h]\n    char *v6;        // [esp+100h] [ebp-144h]\n    unsigned int v7; // [esp+124h] [ebp-120h] BYREF\n    int v8;          // [esp+128h] [ebp-11Ch]\n    int v9;          // [esp+12Ch] [ebp-118h]\n    int v10;         // [esp+130h] [ebp-114h]\n    unsigned char v11[41];   // [esp+13Ch] [ebp-108h] BYREF\n    int savedregs;   // [esp+244h] [ebp+0h] BYREF\n\n    v11[0] = 0xF9;\n    v11[1] = 0x4D;\n    v11[2] = 0x2B;\n    v11[3] = 0xBC;\n    v11[4] = 0x13;\n    v11[5] = 0xDD;\n    v11[6] = 0x13;\n    v11[7] = 0x62;\n    v11[8] = 0xC9;\n    v11[9] = 0xFC;\n    v11[10] = 0xFF;\n    v11[11] = 0x89;\n    v11[12] = 0x7D;\n    v11[13] = 0x4F;\n    v11[14] = 0xC9;\n    v11[15] = 0xF;\n    v11[16] = 0x63;\n    v11[17] = 0x1D;\n    v11[18] = 0x6D;\n    v11[19] = 0x52;\n    v11[20] = 0x50;\n    v11[21] = 0xFD;\n    v11[22] = 0x41;\n    v11[23] = 0xE3;\n    v11[24] = 0x33;\n    v11[25] = 0x76;\n    v11[26] = 0x28;\n    v11[27] = 0x97;\n    v11[28] = 0x38;\n    v11[29] = 0x36;\n    v11[30] = 0xF9;\n    v11[31] = 0x6B;\n    v11[32] = 0x90;\n    v11[33] = 0x39;\n    v11[34] = 0x14;\n    v11[35] = 0x83;\n    v11[36] = 0x2C;\n    v11[37] = 0xE2;\n    v11[38] = 0x2C;\n    v11[39] = 0x1F;\n    v11[40] = 0x0;\n\n    // unsigned int enc[10] = {\n    //     0xBC2B4DF9, 0x6213DD13, 0x89FFFCC9, 0x0FC94F7D, 0x526D1D63, 0xE341FD50, 0x97287633, 0x6BF93638,\n    //     0x83143990, 0x1F2CE22C};\n\n    // unsigned int key[4] = {\n    //     0x12345678, 0x09101112, 0x13141516, 0x15161718};\n    // v8 = *(v11 + 1);\n    // *v6 = v8;\n    unsigned char key[16] =\n        {\n            0x78, 0x56, 0x34, 0x12, 0x12, 0x11, 0x10, 0x09, 0x16, 0x15,\n            0x14, 0x13, 0x18, 0x17, 0x16, 0x15};\n\n    unsigned int *p = (unsigned int *)v11;\n\n    for (int i = 8; i >= 2;i -= 2){\n\n        // *&v11[4 * i + 4] ^= *v11;\n        // *&v11[4 * 1] ^= *v6;\n\n        \n        // *(unsigned int *)&v11[4 * i + 4] ^= p[1];\n        // *(unsigned int *)&v11[4 * i] ^= p[0];\n\n        *(unsigned int *)&v11[4 * i + 4] ^= v11[1];\n        *(unsigned int *)&v11[4 * i] ^= v11[0];\n\n        // enc[i] ^= enc[1];\n        // enc[i - 1] ^= enc[0];\n\n        De_tea(p, (unsigned int *)key);\n        // De_tea((unsigned int *)v11, (unsigned int *)key);\n    }\n\n    De_tea(p, (unsigned int *)key);\n\n    for(int i = 0; i < 40;++ i)\n        printf(\"%c\", v11[i]);\n\n    return 0;\n}\n```\n\n接下来表演的节目是神奇的指针\n\n当我将exp中间部分写成这样时\n\n```c++\n*(unsigned int *)&v11[4 * i + 4] ^= *(unsigned int *)v11[1];\n*(unsigned int *)&v11[4 * i] ^= *(unsigned int *)v11[0];\n```\n\n它的输出是这样的\n\n![image-20240725172154625](image-20240725172154625.png)\n\n当我写成这样时\n\n```C++\nunsigned int *p = (unsigned int *)v11;\n*(unsigned int *)&v11[4 * i + 4] ^= p[1];\n*(unsigned int *)&v11[4 * i] ^= p[0];\n```\n\n它的输出是这样的\n\n![image-20240725172217958](image-20240725172217958.png)\n\n当我写成这样时\n\n```C++\n*(unsigned int *)&v11[4 * i + 4] ^= v11[1];\n*(unsigned int *)&v11[4 * i] ^= v11[0];\n```\n\n它的输出是这样的\n\n![image-20240725172259527](image-20240725172259527.png)\n\n指针，很神奇吧\n","tags":["比赛复现"],"categories":["逆向"]},{"title":"临江仙","url":"/2024/07/25/临江仙/","content":"青山依旧在，几度夕阳红\n<!--more-->\n# 临江仙\n## 【明】杨慎\n滚滚长江东逝水，浪花淘尽英雄。是非成败转头空。青山依旧在，几度夕阳红。\n白发渔樵江渚上，惯看秋月春风。一壶浊酒喜相逢。古今多少事，都付笑谈中。\n","tags":["宋词"],"categories":["古文"]}]